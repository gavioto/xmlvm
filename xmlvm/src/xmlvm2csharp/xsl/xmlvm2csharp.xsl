<?xml version="1.0"?>

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;"><!--new line-->
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs = "http://www.w3.org/2001/XMLSchema"
                xmlns:fn = "http://www.w3.org/2005/xpath-functions"
                xmlns:vm ="http://xmlvm.org"
                xmlns:jvm="http://xmlvm.org/jvm"
                xmlns:dex="http://xmlvm.org/dex"
                version="2.0">

<xsl:output method="text" indent="no"/>

<!-- get this from CSharpOutputProcess -->
<xsl:param name="gen-wrapper" select="'false'"/>
<xsl:param name="gen-skeleton" select="'false'"/>
<xsl:param name="no-using" select="'false'"/>

<xsl:variable name="nl" select="xs:string('&#xa;')"/> <!-- new line -->        

<xsl:param name="clinit" select="'@static'"/>
<xsl:param name="init" select="'@this'"/>
<xsl:param name="finalize" select="'@finally'"/>

<xsl:param name="nonobj-regtype" select="$xmlvm-element-type"/>
<xsl:param name="obj-regtype" select="'global::System.Object'"/>
<xsl:param name="regname" select="'_r'"/>
<xsl:param name="nonobj-regname-suffix" select="''"/>
<xsl:param name="obj-regname-suffix" select="'_o'"/>

<xsl:param name="xmlvm-exception-type" select="vm:get-type('org.xmlvm.Exception')"/>
<xsl:param name="xmlvm-element-type" select="vm:get-type('org.xmlvm.Element')"/>
<xsl:param name="xmlvm-array-type" select="vm:get-type('org.xmlvm.Array')"/>
<xsl:param name="xmlvm-array-interface" select="vm:get-type('org.xmlvm.IArray')"/>
<xsl:param name="xmlvm-red-type" select="vm:get-type('org.xmlvm.runtime.RedTypeMarker')"/>

<xsl:param name="interface-satellite-prefix" select="'_i'"/>
<xsl:param name="field-prefix" select="'_f'"/>

<xsl:param name="keywords" select="('abstract', 'as', 'base', 'bool', 'break', 'byte', 
				   'case', 'catch', 'char', 'checked', 'class', 'const', 'continue', 
				   'decimal', 'default', 'delegate', 'do', 'double', 'else', 'enum',
				   'event', 'explicit', 'extern', 'false', 'finally', 'fixed', 
				   'float', 'for', 'foreach', 'goto', 'if', 'implicit', 
				   'in', 'int', 'interface', 'internal', 'is', 'lock', 'long', 'namespace',
				   'new', 'null', 'object', 'operator', 'out', 'override',
				   'params', 'private', 'protected', 'public', 'readonly', 'ref', 
				   'return', 'sbyte', 'sealed', 'short', 'sizeof', 'stackalloc', 'static', 'string',
				   'struct', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'uint', 'ulong', 
				   'unchecked', 'unsafe', 'ushort', 'using', 
				   'virtual', 'volatile', 'void', 'while')" as="xs:string*"/>

<!-- main template -->
<xsl:template match="vm:xmlvm">
  <xsl:choose>
    <xsl:when test="not($gen-skeleton='true')">
      <xsl:text>// Automatically generated by xmlvm2csharp. </xsl:text>
      <xsl:text>Do not edit!&nl;</xsl:text> 
      <!--<xsl:value-of select="fn:concat('// ','blah\134012halb= ',vm:xmlvmToUnicode('blah\134012halb'))"/> -->
      <xsl:text>&nl;using </xsl:text>
      <xsl:value-of select="vm:get-type('org.xmlvm')"/>
      <xsl:text>;&nl;</xsl:text>
      <xsl:if test="not($no-using='true')">
	<xsl:text>using </xsl:text>
	<xsl:value-of select="vm:get-type('java')"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="vm:get-type('org.xmlvm.java')"/>
	<xsl:text>;&nl;</xsl:text> 	
      </xsl:if>
      <xsl:for-each select="vm:class">
	<xsl:if test="not($gen-wrapper='true' and @isPrivate='true')">
	  <xsl:call-template name="emit-namespace"/>
	</xsl:if>
      </xsl:for-each>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emit-native-skeleton"/>
    </xsl:otherwise>
  </xsl:choose> 
</xsl:template>

<xsl:template name="emit-native-skeleton">
  <xsl:apply-templates select="vm:method[@isNative='true']"/>
</xsl:template>

<xsl:template name="emit-main-method">
  <xsl:param name="override" select="'false'"/>
  <xsl:text>&nl;public static </xsl:text>
  <xsl:if test="$override='true'">
    <xsl:text>new </xsl:text>
  </xsl:if>
  <xsl:text>void Main(global::System.String[] args) {&nl;</xsl:text>
  <xsl:text>    // first convert to java strings, then call main():&nl;</xsl:text>
  <xsl:text>    java.lang.String[] jargs = null;&nl;</xsl:text>
  <xsl:text>    if (args != null) {&nl;</xsl:text>
  <xsl:text>        jargs = new java.lang.String[args.Length];&nl;</xsl:text>
  <xsl:text>        for (int i=0; i&lt;args.Length; i++) {&nl;</xsl:text>
  <xsl:text>            jargs[i] = new java.lang.String();&nl;</xsl:text>
  <xsl:text>            jargs[i].</xsl:text>
  <xsl:value-of select="fn:concat($init,'(new ',vm:get-xmlvm-array('char'))"/>
  <xsl:text>(args[i].ToCharArray()));&nl;</xsl:text>
  <xsl:text>        }&nl;</xsl:text>
  <xsl:text>    }&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:get-member-name('main')"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="fn:concat('new ', $xmlvm-array-type, 
			          '&lt;', 
				  $obj-regtype, 
				  '&gt;', '(jargs)')"/>
  <xsl:text>);&nl;    return;&nl;}&nl;&nl;</xsl:text>
</xsl:template>

<xsl:template name="emit-static-constructor">
  <xsl:param name="name" as="xs:string"/>
  <xsl:param name="strings" as="node()*"/>
  <xsl:param name="has-clinit" as="xs:boolean"/>
  <xsl:text>&nl;static </xsl:text>
  <xsl:value-of select="$name"/>
  <xsl:text>() {&nl;</xsl:text>
  <xsl:for-each select="$strings">
    <xsl:text>    </xsl:text>
    <xsl:value-of select="vm:get-member-name(@name,true())"/>
    <xsl:text> = </xsl:text>
    <xsl:text>new </xsl:text>
    <xsl:value-of select="vm:get-type('java.lang.String')"/>
    <xsl:text>();&nl;</xsl:text>
    <xsl:text>    </xsl:text>    		    
    <xsl:value-of select="vm:get-member-name(./@name,true())"/>
    <xsl:text>.</xsl:text>
    <xsl:value-of select="fn:concat($init,'(new ',vm:get-xmlvm-array('char'))"/>
    <xsl:text>(</xsl:text>
    <xsl:value-of select="vm:escape-string(./@value)"/>
    <xsl:text>.ToCharArray()));&nl;</xsl:text>
  </xsl:for-each>
  <xsl:if test="$has-clinit">
    <xsl:text>    </xsl:text>
    <xsl:value-of select="$clinit" />
    <xsl:text>();&nl;</xsl:text>
  </xsl:if>
  <xsl:text>}&nl;&nl;</xsl:text>
</xsl:template>

<xsl:template name="emit-instance-constructor">
  <xsl:param name="name" as="xs:string"/>
  <xsl:param name="strings" as="node()*"/>
  <xsl:text>&nl;public </xsl:text>
  <xsl:value-of select="$name"/> 
  <xsl:text>() {&nl;</xsl:text>
  <xsl:for-each select="$strings">
    <xsl:text>    </xsl:text>
    <xsl:value-of select="vm:get-member-name(@name,true())"/>
    <xsl:text> = </xsl:text>
    <xsl:text>new </xsl:text>
    <xsl:value-of select="vm:get-type('java.lang.String')"/>
    <xsl:text>();&nl;</xsl:text>
    <xsl:text>    </xsl:text>    		    
    <xsl:value-of select="vm:get-member-name(./@name,true())"/>
    <xsl:text>.</xsl:text>
    <xsl:value-of select="fn:concat($init,'(new ',vm:get-xmlvm-array('char'))" /> <!-- " -->
    <xsl:text>(</xsl:text>
    <xsl:value-of select="vm:escape-string(./@value)"/>
    <xsl:text>.ToCharArray()));&nl;</xsl:text>
  </xsl:for-each>
  <xsl:text>}&nl;&nl;</xsl:text>
</xsl:template>


<xsl:template name="emit-namespace">
  <xsl:variable name="namespace" select="vm:get-type(@package)"/>
  <xsl:choose>
    <xsl:when test="$namespace and not($namespace='')">
      <xsl:text>namespace </xsl:text>
      <xsl:value-of select="$namespace"/>
      <xsl:text> {&nl;</xsl:text>
      <xsl:choose>
	<xsl:when test="@isInterface='true'">
	  <xsl:call-template name="emit-interface">
	    <xsl:with-param name="namespace" select="$namespace"/>
	  </xsl:call-template>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:call-template name="emit-class">
	    <xsl:with-param name="namespace" select="$namespace"/>
	  </xsl:call-template>
	</xsl:otherwise>
      </xsl:choose>
      <xsl:text>} // end of namespace: </xsl:text>
      <xsl:value-of select="$namespace"/>
      <xsl:text>&nl;</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emit-class"/>		
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emit-class">
  <xsl:param name="namespace" as="xs:string" select="''"/>
  <xsl:variable name="class-name" select="vm:get-member-name(@name)"/>		  
  <!-- step 1: (modifier)* (interface | class) (ClassName) : (ParentType) "{" -->  
  <xsl:value-of select="fn:string-join(vm:get-modifiers(.),' ')"/>
  <xsl:text> </xsl:text>
  <!--
  <xsl:choose>
    <xsl:when test="@isInterface = 'true'">
      <xsl:text>interface </xsl:text>
    </xsl:when>
    <xsl:otherwise>
  -->
      <xsl:text>class </xsl:text>
  <!--
    </xsl:otherwise>
  </xsl:choose>  	
  -->
  <xsl:value-of select="$class-name"/>
  <xsl:variable name="cs-parents" as="xs:string*">
    <xsl:if test="not ((@package='org.xmlvm.java.lang' 
		    and @name='Object') 
		   or (@package='java.lang'
		       and @name='Object')
		   or (@isInterface='true'))">
      <xsl:value-of select="vm:get-type(@extends)"/>
    </xsl:if>
    <xsl:for-each select="fn:tokenize(@interfaces, ',')">
      <xsl:sequence select="vm:get-type(.)"/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:value-of select="if (exists($cs-parents))
			  then fn:concat(': ', fn:string-join($cs-parents, ','))
			  else ''"/>
  <xsl:text> {&nl;</xsl:text>
  <!-- step 2a: emit Main() if needed -->
  <xsl:if test="vm:method/@name = 'main'">
    <xsl:choose>
      <xsl:when test="vm:method[@name='main']/@isOverride='true'">
    	<xsl:call-template name="emit-main-method">
	  <xsl:with-param name="override" select="'true'"/>
	</xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
    	<xsl:call-template name="emit-main-method">
	  <xsl:with-param name="override" select="'false'"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <!-- 
     step 2b: emit a csharp static constructor if needed 
     (e.g. java code contained static initialization block 
  -->
  <xsl:variable name="has-clinit" as="xs:boolean" select="vm:method/@name = '&lt;clinit&gt;'"/>
  <xsl:variable name="static-strings" as="node()*" 
		select="vm:field[@type='java.lang.String' and @isStatic='true' and @value]"/>
  <xsl:if test="$has-clinit or $static-strings">
    <xsl:call-template name="emit-static-constructor">
      <xsl:with-param name="name" select="$class-name"/>
      <xsl:with-param name="strings" select="$static-strings"/>
      <xsl:with-param name="has-clinit" select="$has-clinit"/>
    </xsl:call-template>
  </xsl:if>
  <!--
     step 2c: emit an instance constructor to initialize strings, if needed
  -->
  <xsl:variable name="instance-strings" as="node()*" 
		select="vm:field[@type='java.lang.String' and not(@isStatic='true') and @value]"/>
  <xsl:if test="$instance-strings">
    <xsl:call-template name="emit-instance-constructor">
      <xsl:with-param name="name" select="$class-name"/>
      <xsl:with-param name="strings" select="$instance-strings"/>
    </xsl:call-template>
  </xsl:if>
  <!-- step 3: emit variable definition for all fields (both static and non-static) -->
  <xsl:apply-templates select="vm:field"/>
  <!-- step 4: emit methods -->
  <xsl:apply-templates select="vm:method"/>
  <!-- step 5: end of class implementation -->
  <xsl:if test="$gen-wrapper='true'">
    <xsl:call-template name="emit-wrapper-comments">
      <xsl:with-param name="member" select="''"/>
      <xsl:with-param name="package" select="@package"/>
      <xsl:with-param name="class" select="@name"/>    		    		
    </xsl:call-template>
  </xsl:if>
  <xsl:text>&nl;} // end of class: </xsl:text>
  <xsl:value-of select="$class-name"/>
  <xsl:text>&nl;&nl;</xsl:text>
</xsl:template> <!-- end of template: emitClass -->


<xsl:template name="emit-interface">
  <xsl:param name="namespace" as="xs:string" select="''"/>
  <xsl:variable name="class-name" select="vm:get-member-name(@name)"/>
  <xsl:variable name="interface-satellite-name" select="vm:get-interface-satellite-name(@name)"/>
  <xsl:variable name="extend-str">
    <xsl:variable name="cs-parents" as="xs:string*">
      <xsl:for-each select="fn:tokenize(@interfaces, ',')">
	<xsl:sequence select="vm:get-type(.)"/>
      </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="if (exists($cs-parents))
			    then fn:concat(': ', fn:string-join($cs-parents, ','))
			    else ''"/>
  </xsl:variable>
   <!-- 
     step 1, emit an abstract class named '_i'+$class-name
     with all static fields
     (so it cannot be instantiated): 
     (modifier)* abstract class (InterfaceName) "{" 
    -->  
  <xsl:value-of select="fn:string-join(vm:get-modifiers(.),' ')"/>
  <xsl:text> abstract class </xsl:text>
  <xsl:value-of select="$interface-satellite-name"/>
  <xsl:value-of select="$extend-str"/>
  <xsl:text> {&nl;</xsl:text>
  <!-- 
     step 1b: emit a csharp static constructor if needed 
     (e.g. java code contained static initialization block 
  -->
  <xsl:variable name="has-clinit" as="xs:boolean"
               select="vm:method/@name = '&lt;clinit&gt;'"/>
  <xsl:variable name="static-strings" as="node()*"
               select="vm:field[@type='java.lang.String' and @isStatic='true' and @value]"/>
  <xsl:if test="$has-clinit or $static-strings">
    <xsl:call-template name="emit-static-constructor">
      <xsl:with-param name="name" select="$interface-satellite-name"/>
      <xsl:with-param name="strings" select="$static-strings"/>
      <xsl:with-param name="has-clinit" select="$has-clinit"/>
    </xsl:call-template>
  </xsl:if>
  <!-- step 1c: emit <clinit> method if it exists-->
  <!--<xsl:apply-templates select="vm:method[@name='&lt;clinit&gt;']"/> -->
  <xsl:apply-templates select="vm:method[@isStatic and @isStatic='true']"/>
  <!-- 
     step 1d: emit variable definition for all fields 
     (they should all be static and constants) 
    -->
  <xsl:apply-templates select="vm:field"/>
  <!-- step 1d: end of abstract class -->
  <xsl:text>&nl;} // end of abstract class: </xsl:text>
  <xsl:value-of select="$interface-satellite-name"/>
  <xsl:text>&nl;&nl;</xsl:text>
  <!-- 
     step 2: emit an interface $clname 
     containing all interface method
    -->
  <xsl:value-of select="fn:string-join(vm:get-modifiers(.),' ')"/>
  <xsl:text> interface </xsl:text>
  <xsl:value-of select="$class-name"/>
  <xsl:value-of select="$extend-str"/>
  <xsl:text> {&nl;</xsl:text>
  <!-- step 2b: emit all interface methods -->
  <xsl:apply-templates select="vm:method[not(@isStatic and @isStatic='true')]"/>
  <!-- step 2c: end of interface -->
  <xsl:if test="$gen-wrapper='true'">
    <xsl:call-template name="emit-wrapper-comments">
      <xsl:with-param name="member" select="''"/>
      <xsl:with-param name="package" select="@package"/>
      <xsl:with-param name="class" select="@name"/>    		    		
    </xsl:call-template>
  </xsl:if>
  <xsl:text>&nl;} // end of interface: </xsl:text>
  <xsl:value-of select="$class-name"/>
  <xsl:text>&nl;&nl;</xsl:text>
</xsl:template>


<xsl:template match="vm:field">
  <xsl:if test="not($gen-wrapper='true' and @isPrivate='true')">
    <xsl:value-of select="fn:string-join(vm:get-modifiers(.),' ')" />
    <xsl:text> </xsl:text>    		    
    <xsl:value-of select="vm:get-type(@type)" />
    <xsl:text> </xsl:text>
    <xsl:value-of select="vm:get-member-name(@name,true())"/>
    <xsl:if test="@value">
      <xsl:choose>
	<xsl:when test="vm:is-object-ref(@type) and not(@type = 'java.lang.String')">
	  <xsl:text> = </xsl:text>
	  <xsl:text>null</xsl:text>
	</xsl:when>
	<xsl:when test="@type = 'java.lang.String'">
	  <!-- do nothing! value will be assigned in static or instance constructor -->
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text> = </xsl:text>
	  <xsl:value-of select="vm:get-native-value(@value,@type)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:text>;&nl;&nl;</xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template match="vm:method">
  <xsl:if test="not(vm:is-red-duplicate(.)) 
		and not($gen-wrapper='true' and @isPrivate='true')">
    <xsl:value-of select="fn:string-join(vm:get-modifiers(.),' ')"/>
    <xsl:text> </xsl:text>
    <xsl:if test="not(@isStatic and @isStatic='true') 
      	  	      and not(@isPrivate and @isPrivate='true') 
      		      and not(@isFinal and @isFinal='true')
		      and not(@name='&lt;init&gt;')">
      <xsl:choose>
	<xsl:when test="@isOverride and @isOverride='true'
			and not(../@isInterface or ../@isInterface='true') ">
	  <xsl:text>override </xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:if test="not(../@isInterface='true' or @isAbstract='true')">
	    <xsl:text>virtual </xsl:text>
	  </xsl:if>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <xsl:if test="@isOverride='true' 
      		  and not(@isPrivate and @isPrivate='true') 
		  and ((@isStatic and @isStatic='true') 
		       or (@isFinal and @isFinal='true') 
		       or (@name='&lt;init&gt;'))">
      <xsl:text>new </xsl:text>
    </xsl:if>
    <xsl:value-of select="vm:get-method-signature(.)"/>
    <xsl:choose>
      <xsl:when test="(../.[@isInterface = 'true'] or @isAbstract = 'true') and not(@isStatic='true')">
        <xsl:text>;&nl;&nl;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>{&nl;</xsl:text>
	<xsl:choose>
	  <xsl:when test="$gen-wrapper='true' or @isNative='true'">
	    <xsl:call-template name="emit-wrapper-comments">
	      <xsl:with-param name="member" select="vm:get-method-signature(., false())"/>
	      <xsl:with-param name="package" select="../@package"/>
	      <xsl:with-param name="class" select="../@name"/>
	    </xsl:call-template>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:call-template name="initArguments" />
	    <xsl:apply-templates/>
	  </xsl:otherwise>
	</xsl:choose>
	<xsl:text>}&nl;&nl;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>


<xsl:template match="vm:signature">
  <!-- Do nothing -->
</xsl:template>

<xsl:function name="vm:get-type" as="xs:string">
  <xsl:param name="j-type" as="xs:string"/>
  <xsl:param name="isRedType" as="xs:string?"/>
  <xsl:value-of select="if ($isRedType and $isRedType='true') 
			then $xmlvm-red-type
			else vm:get-type($j-type)"/>
</xsl:function>

<!-- converts the given java type to csharp -->
<xsl:function name="vm:get-type" as="xs:string">
  <xsl:param name="j-type" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="$j-type = 'void'">
      <xsl:value-of select="'void'" />
    </xsl:when>
    <xsl:when test="$j-type = 'char'">
      <xsl:value-of select="'char'" />
    </xsl:when>
    <xsl:when test="$j-type = 'byte'">
      <xsl:value-of select="'sbyte'" />
    </xsl:when>
    <xsl:when test="$j-type = 'short'">
      <xsl:value-of select="'short'" />
    </xsl:when>
    <xsl:when test="$j-type = 'int'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="$j-type = 'long'">
      <xsl:value-of select="'long'" />
    </xsl:when>
    <xsl:when test="$j-type = 'float'">
      <xsl:value-of select="'float'" />
    </xsl:when>
    <xsl:when test="$j-type = 'double'">
      <xsl:value-of select="'double'" />
    </xsl:when>
    <xsl:when test="$j-type = 'boolean'">
      <xsl:value-of select="'bool'" />
    </xsl:when>
    <xsl:when test="ends-with($j-type, '[]')">
      <xsl:variable name="base-type" select="vm:get-array-base-type($j-type)"/>
      <xsl:value-of select="fn:concat($xmlvm-array-type,
			              '&lt;', 
				      if (vm:is-object-ref($base-type))
				        then $obj-regtype
					else vm:get-type($base-type),
				      '&gt;')" />
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="cs-types" as="xs:string*">
    	<xsl:for-each select="fn:tokenize($j-type,'\.')">
   	  <xsl:sequence select="vm:get-member-name(.)"/>
    	</xsl:for-each>
      </xsl:variable>
      <xsl:value-of select="fn:string-join($cs-types,'.')"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<xsl:function name="vm:get-reg-value" as="xs:string">
  <xsl:param name="value" as="xs:string"/>
  <xsl:param name="type" as="xs:string"/>
  <xsl:value-of select="vm:get-value-helper($value,$type,false())"/>
</xsl:function>

<xsl:function name="vm:get-native-value" as="xs:string">
  <xsl:param name="value" as="xs:string"/>
  <xsl:param name="type" as="xs:string"/>
  <xsl:value-of select="vm:get-value-helper($value,$type,true())"/>
</xsl:function>

<xsl:function name="vm:get-value-helper" as="xs:string">
  <xsl:param name="value" as="xs:string"/>
  <xsl:param name="type" as="xs:string"/>
  <xsl:param name="is-native" as="xs:boolean"/>
  <xsl:variable name="valSuffix" as="xs:string">
    <xsl:choose>
      <xsl:when test="$type='float'">
	<xsl:text>D</xsl:text>
      </xsl:when>
      <xsl:when test="$type='double'">
	<xsl:text>D</xsl:text>
      </xsl:when>
      <xsl:when test="$type='long'">
	<xsl:text>L</xsl:text>
      </xsl:when>
      <xsl:when test="$type='boolean' and $is-native">
	<xsl:text>!=0</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="''"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="valCast" as="xs:string">
    <xsl:choose>
      <xsl:when test="$type='float'">
	<xsl:text>(float)</xsl:text>
      </xsl:when>
      <xsl:when test="$type='char' and $is-native">
	<xsl:text>(char)</xsl:text>
      </xsl:when>
      <xsl:when test="$type='char' and $is-native">
	<!-- this is kinda redundant, but is left for clarity -->
	<xsl:text>(int)</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="''"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <!-- 
     return concat of $valCast $value and $valSuffix, 
     unless it is a special value (NaN, infinities, etc):
  -->
  <xsl:choose>
    <xsl:when test="$value='Infinity' and $type='float'">
      <xsl:text>global::System.Single.PositiveInfinity</xsl:text>
    </xsl:when>
    <xsl:when test="$value='Infinity' and $type='double'">
      <xsl:text>global::System.Double.PositiveInfinity</xsl:text>
    </xsl:when>
    <xsl:when test="$value='-Infinity' and $type='float'">
      <xsl:text>global::System.Single.NegativeInfinity</xsl:text>
    </xsl:when>
    <xsl:when test="$value='-Infinity' and $type='double'">
      <xsl:text>global::System.Double.NegativeInfinity</xsl:text>
    </xsl:when>
    <xsl:when test="$value='NaN' and $type='float'">
      <xsl:text>global::System.Single.NaN</xsl:text>
    </xsl:when>
    <xsl:when test="$value='NaN' and $type='double'">
      <xsl:text>global::System.Double.NaN</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="fn:concat($valCast, $value, $valSuffix)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<!-- checks whether the given string is a csharp reserved word -->
<xsl:function name="vm:is-keyword" as="xs:boolean">
	<xsl:param name="word" as="xs:string"/>
	<xsl:value-of select="$keywords=$word"/>
</xsl:function>

<!-- by default, assume not a field -->
<xsl:function name="vm:get-member-name" as="xs:string">
  <xsl:param name="name" as="xs:string"/>
  <xsl:value-of select="vm:get-member-name($name,false())"/>
</xsl:function>


<!-- 
   1. escapes '$'
   2. prefixes field identifiers (to avoid clash with method identifiers)
   3. converts <init> and <clinit> into $init and $clinit repectively 
   4. escapes csharp reserved words with @,
-->
<xsl:function name="vm:get-member-name" as="xs:string">
  <xsl:param name="name" as="xs:string"/>
  <xsl:param name="is-field" as="xs:boolean"/>
  <!-- 
     step 1:
     the following code escapes dollars in java names 
     without nameclashes using the one-to-one transformation:
     '_' to '_1'
     '$' to '_2'
     note: of course it is important to transform '_' first...
  -->
  <xsl:variable name="dollar-escaped-name" as="xs:string" 
		select="fn:replace(fn:replace($name, '_', '_1'), '\$', '_2')"/>
  <!-- 
     step 2:
     the following escape field identifiers (to avoid clash with method identifiers.
     important: has to be done after dollar escape
  -->
  <xsl:variable name="field-escaped-name" as="xs:string"
		select="if ($is-field)
			then fn:concat($field-prefix,$dollar-escaped-name)
			else $dollar-escaped-name"/>
  <!-- 
     step 3:
     escape brakets (e.g. <init>)
  -->
  <xsl:variable name="braket-escaped-name" as="xs:string"
		select="if ($field-escaped-name = '&lt;init&gt;')
			then $init
			else if ($field-escaped-name = '&lt;clinit&gt;')
			     then $clinit
			     else if ($field-escaped-name = 'finalize')
			          then $finalize
				  else $field-escaped-name"/>
  <!--
     step 4: 
     escape csharp keywords
     note: this should be the last step
  -->
  <xsl:value-of select="if (vm:is-keyword($braket-escaped-name))
			then fn:concat('@',$braket-escaped-name)
			else $braket-escaped-name"/>
</xsl:function>

<xsl:function name="vm:get-interface-satellite-name" as="xs:string">
  <xsl:param name="name" as="xs:string"/>
  <xsl:value-of select="fn:concat($interface-satellite-prefix, 
			          vm:get-member-name($name))"/>
</xsl:function>


<!-- get the modifiers of the given node -->
<xsl:function name="vm:get-modifiers" as="xs:string*">
	<xsl:param name="member-node" as="node()"/>
	<xsl:if test="not($member-node/../@isInterface='true')">
	  <xsl:choose>
	    <xsl:when test="$member-node/@isPublic = 'true'">
    	      <xsl:sequence select="'public'"/>
	    </xsl:when>
	    <xsl:when test="$member-node/@isPrivate = 'true'">
    	      <xsl:sequence select="'private'"/>
	    </xsl:when>	
	    <xsl:when test="$member-node/@isProtected = 'true'">
    	      <xsl:sequence select="'protected'"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <!-- package-scope -->
	      <xsl:sequence select="'public'"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:if>
	<xsl:if test="$member-node/@isStatic = 'true'">
	  <xsl:sequence select="'static'"/>
	</xsl:if>
	<xsl:if test="$member-node/@isAbstract = 'true' 
		        and not($member-node/../@isInterface='true')
			and not($member-node/@isInterface='true')">
    	  <xsl:sequence select="'abstract'"/>
	</xsl:if>
</xsl:function>


<!-- 
	returns (by default) the csharp signature of the given method node 
	as "returnType methodName (type n1, type n2, ...)" 
-->
<xsl:function name="vm:get-method-signature" as="xs:string">
	<xsl:param name="method-node" as="node()"/>
	<xsl:value-of select="vm:get-method-signature($method-node, true())"/>
</xsl:function>

<!-- " -->
<!-- 
	returns the csharp or java signature (as determined by csharpMode) 
	of the given method node as "returnType methodName (type n1, type n2, ...)" 
-->
<xsl:function name="vm:get-method-signature" as="xs:string">
	<xsl:param name="method-node" as="node()"/>
	<xsl:param name="csharp-mode" as="xs:boolean"/>

	<xsl:variable name="java-return-type" 
		      select="$method-node/vm:signature/vm:return/@type"/>
	<xsl:variable name="return-type" 
		select="if ($csharp-mode)
				then if (vm:is-object-ref($java-return-type))
				      then $obj-regtype 
				      else vm:get-type($java-return-type)
				else $java-return-type"/>
	<xsl:variable name="method-name" 
		select="if ($csharp-mode) 
				then vm:get-member-name($method-node/@name) 
				else $method-node/@name"/>
	<xsl:variable name="params" as="xs:string*">
		<xsl:sequence select="'('"/>
		<xsl:for-each select="$method-node/vm:signature/vm:parameter">
    		  <xsl:sequence select="if ($csharp-mode)
    					  then vm:get-type(@type,@isRedType)
    					  else @type"/>
    		  <xsl:if test="$csharp-mode">
    		    <xsl:sequence select="' n'"/>
    		    <xsl:sequence select="xs:string(position())"/>
    		  </xsl:if>
    		  <xsl:if test="not(position()=last())">
    		    <xsl:sequence select="', '"/>
    		  </xsl:if>
		</xsl:for-each>
 		<xsl:sequence select="')'"/>
	</xsl:variable>
	<xsl:value-of select="fn:concat($return-type,' ', $method-name, 
    			                fn:string-join($params,''))" />
</xsl:function>


<xsl:template name="emit-wrapper-comments">
	<xsl:param name="member"/>
	<xsl:param name="package"/>
	<xsl:param name="class"/>
	<xsl:variable name="tag" as="xs:string*">
		<xsl:sequence select="$package"/>
		<xsl:if test="$package and not($package='')">
			<xsl:sequence select="'.'"/>	
		</xsl:if>
		<xsl:sequence select="$class"/>
		<xsl:if test="$member and not($member='')">
			<xsl:sequence select="': '"/>
			<xsl:sequence select="$member"/>	
		</xsl:if>
	</xsl:variable>
	<xsl:variable name="tag-str" select="fn:string-join($tag,'')"/>
	<xsl:text>//XMLVM_BEGIN_WRAPPER[</xsl:text>
	<xsl:value-of select="$tag-str"/>
	<xsl:text>]&nl;</xsl:text>
	<xsl:if test="self::vm:method">
	  <xsl:text>      throw new </xsl:text>
	  <xsl:value-of select="vm:get-type('org.xmlvm.NotYetImplementedException')"/>
	  <xsl:text>(&quot;</xsl:text>
	  <xsl:text>native/wrapper method not yet implemented</xsl:text>
	  <xsl:text>&quot;);&nl;</xsl:text>
	</xsl:if>
	<xsl:text>//XMLVM_END_WRAPPER[</xsl:text>
	<xsl:value-of select="$tag-str"/>	
	<xsl:text>]&nl;</xsl:text>
</xsl:template>



<!--  javac will sometimes generate two methods that only differ in their return type.
      This can happen e.g. with type erasures. Function vm:isDuplicateMethod will determine
      if the given method is a duplicate that is not needed when generating Objective-C (in fact,
      Objective-C does not permit two methods that only differ in their return type).
      A method is a duplicate if it is (1) synthetic, (2) a method with the same name exists
      in the class, and (3) signatures only differ in their return types.  -->
<xsl:function name="vm:isDuplicateMethod" as="xs:boolean">
  <xsl:param name="method" as="node()"/>
  <xsl:choose>
    <xsl:when test="not($method/@isSynthetic = 'true')">
      <xsl:value-of select="false()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="name" select="$method/@name"/>
      <xsl:variable name="methodsWithSameName" select="$method/../vm:method[@name = $name]"/>
      <xsl:variable name="duplicateMethods">
        <xsl:for-each select="$methodsWithSameName">
          <xsl:if test="deep-equal($method/vm:signature/vm:parameter, ./vm:signature/vm:parameter)">
            <xsl:copy-of select="."/>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:value-of select="count($duplicateMethods/vm:method) gt 1"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<xsl:function name="vm:is-red-duplicate" as="xs:boolean">
  <xsl:param name="method" as="node()"/>
  <xsl:variable name="method-name" select="$method/@name" as="xs:string"/>
  <xsl:variable name="method-params" as="xs:string*">
    <xsl:for-each select="$method/vm:signature/vm:parameter">
      <xsl:sequence select="vm:get-type(./@type, ./@isRedType)"/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:variable name="encountered-duplicates" as="xs:boolean*">
    <xsl:for-each select="$method/preceding-sibling::vm:method[@name=$method-name]">
      <xsl:variable name="other-method-params" as="xs:string*">
	<xsl:for-each select="./vm:signature/vm:parameter">
	  <xsl:sequence select="vm:get-type(./@type, ./@isRedType)"/>
	</xsl:for-each>
      </xsl:variable>
      <xsl:sequence select="if (fn:deep-equal($method-params,$other-method-params))
			      then true()
			      else false()"/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:value-of select="$encountered-duplicates=true()"/>
</xsl:function>


<xsl:function name="vm:is-object-ref" as="xs:boolean">
  <xsl:param name="type" as="xs:string"/>
  <xsl:value-of select="not($type='byte' or $type='short' 
			    or $type='int' or $type='float' 
			    or $type='long' or $type='double' or
                            $type='char' or $type='boolean' or $type='void')"/>
</xsl:function>



<xsl:template name="emit-register-decl">
  <xsl:param name="num"/>
  <!-- value register -->
  <xsl:variable name="nonobj-regname" as="xs:string">
    <xsl:value-of select="fn:concat($regname,$num,$nonobj-regname-suffix)"/>    
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj-regtype"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="$nonobj-regname"/>
  <xsl:text>;&nl;</xsl:text>
  <!-- initialize -->
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj-regname"/>
  <xsl:text>.i = 0;&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj-regname"/>
  <xsl:text>.l = 0;&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj-regname"/>
  <xsl:text>.f = 0;&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj-regname"/>
  <xsl:text>.d = 0;&nl;</xsl:text>
  <!-- object register -->
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$obj-regtype"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="$regname"/>
  <xsl:value-of select="$num"/>
  <xsl:value-of select="$obj-regname-suffix"/>
  <xsl:text> = null;&nl;</xsl:text>
</xsl:template>


<xsl:template name="emit-register-name">
  <xsl:param name="num" />
  <xsl:param name="type" />
  <xsl:value-of select="$regname"/>
  <xsl:value-of select="$num"/>
  <xsl:value-of select="vm:getTypeAccess($type)"/>
</xsl:template>

<xsl:function name="vm:getTypeAccess" as="xs:string">
  <xsl:param name="type" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="$type = 'boolean' or $type = 'byte' 
		    or $type = 'char' or $type = 'short' or $type = 'int'">
      <xsl:value-of select="fn:concat($nonobj-regname-suffix, '.i')"/>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:value-of select="fn:concat($nonobj-regname-suffix, '.f')"/>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:value-of select="fn:concat($nonobj-regname-suffix, '.d')"/>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:value-of select="fn:concat($nonobj-regname-suffix, '.l')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$obj-regname-suffix"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<!-- adopted from xmlvm2c.xsl -->
<xsl:template name="initArguments">
  <xsl:variable name="numRegs" select="dex:code/@register-size" as="xs:integer"/>
  <xsl:variable name="numArgs" select="count(vm:signature/vm:parameter)" as="xs:integer"/>
  <xsl:for-each select="1 to $numRegs">
    <xsl:call-template name="emit-register-decl">
      <xsl:with-param name="num" select="position()-1"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:apply-templates select="dex:var"/>
<!--
  <xsl:if test="not(@isStatic = 'true')">
    Initialize 'this' parameter 
    <xsl:text>    </xsl:text>
    <xsl:call-template name="emit-register-name">
    	<xsl:with-param name="num" select="$numRegs - ($numArgs + 1)"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
    <xsl:text> = this;&nl;</xsl:text>
  </xsl:if>
  <xsl:for-each select="vm:signature/vm:parameter">
    <xsl:text>    </xsl:text>
    <xsl:call-template name="emit-register-name">
    	<xsl:with-param name="num" select="$numRegs - ($numArgs - position()) - 1"/>
	no need to consider @isRedType, since in any case '_o' will be emitted 
    	<xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
    <xsl:choose>
      <xsl:when test="@type='boolean'">
	<xsl:text>n</xsl:text>
	<xsl:value-of select="position()"/>
	<xsl:text> ? 1 : 0</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>n</xsl:text>
	<xsl:value-of select="position()"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>;&nl;</xsl:text>
  </xsl:for-each>
-->
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$xmlvm-exception-type"/>
  <xsl:text> _ex = null;&nl;</xsl:text>
</xsl:template>


  
<xsl:template match="vm:annotations">
  <!-- Ignore annotations -->
</xsl:template>


<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- DEX Templates -->
<!-- http://www.netmite.com/android/mydroid/dalvik/docs/dalvik-bytecode.html-->
<!-- http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html -->


<xsl:template match="dex:code">
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="vm:set-null">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
  	<xsl:with-param name="type" select="'obj'"/>
  	<xsl:with-param name="num" select="@num"/>
  </xsl:call-template>
  <xsl:text> = null;&nl;</xsl:text>
</xsl:template>

<xsl:template match="vm:move-argument">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
  	<xsl:with-param name="type" select="@vx-type"/>
  	<xsl:with-param name="num" select="@vx"/>
  </xsl:call-template>
 <xsl:if test="@sourceArg = 'self'">
   <xsl:text> = self;&nl;</xsl:text>
 </xsl:if>
 <xsl:if test="@sourceArg != 'self'">
   <xsl:text> = n</xsl:text><xsl:value-of select="@sourceArg"/>
 <xsl:text>;
</xsl:text>
 </xsl:if>
</xsl:template>

<xsl:template match="dex:var">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@register"/>
    <xsl:with-param name="type" select="@type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:choose>
    <xsl:when test="@name='this'">
      <xsl:text>this</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>n</xsl:text>
      <xsl:value-of select="@param-index + 1"/>
      <xsl:if test="@type='boolean'">
	<xsl:text> ? 1 : 0</xsl:text>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="vm:source-position">
</xsl:template>


<xsl:template match="dex:invoke-static|dex:invoke-static-range">
  <xsl:variable name="return-type" select="dex:parameters/dex:return/@type" as="xs:string"/>
  <xsl:variable name="is-assigned" select="($return-type != 'void') and dex:move-result" as="xs:boolean"/>
  <xsl:text>    </xsl:text>
  <xsl:if test="$is-assigned">
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="dex:move-result/@vx" />
      <xsl:with-param name="type" select="$return-type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:value-of select="vm:get-type(@class-type)"/>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:get-member-name(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:choose>
      <xsl:when test="@type='boolean'">
	<xsl:text>0!=</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="vm:get-type(@type,@isRedType)"/>
	<xsl:text>) </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>)</xsl:text>
  <xsl:if test="$is-assigned and $return-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:invoke-direct|dex:invoke-direct-range
		     |dex:invoke-virtual|dex:invoke-virtual-range
		     |dex:invoke-interface|dex:invoke-interface-range">
  <xsl:variable name="return-type" select="dex:parameters/dex:return/@type" as="xs:string"/>
  <xsl:variable name="is-assigned" select="($return-type != 'void') and dex:move-result" as="xs:boolean"/>
  <xsl:text>    </xsl:text>
  <xsl:if test="$is-assigned">
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="dex:move-result/@vx"/>
      <xsl:with-param name="type" select="$return-type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>((</xsl:text>
  <xsl:value-of select="vm:get-type(@class-type)"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@register"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:get-member-name(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:choose>
      <xsl:when test="@type='boolean'">
	<xsl:text>0!=</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="vm:get-type(@type,@isRedType)"/>
	<xsl:text>) </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="emit-register-name">
    		<xsl:with-param name="num" select="@register"/>
    		<xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>)</xsl:text>
  <xsl:if test="$is-assigned and $return-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:invoke-super|dex:invoke-super-range">
  <xsl:variable name="return-type" select="dex:parameters/dex:return/@type" as="xs:string"/>
  <xsl:variable name="is-assigned" select="($return-type != 'void') and dex:move-result" as="xs:boolean"/>
  <xsl:text>    </xsl:text>
  <xsl:if test="$is-assigned">
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="dex:move-result/@vx"/>
      <xsl:with-param name="type" select="$return-type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>base</xsl:text>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:get-member-name(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:choose>
      <xsl:when test="@type='boolean'">
	<xsl:text>0!=</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="vm:get-type(@type,@isRedType)"/>
	<xsl:text>) </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>)</xsl:text>
  <xsl:if test="$is-assigned and $return-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:monitor-enter">
  <!-- We can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter in order
       to handle exceptions. Also, wait() and wait(long) need to be
       able to release the Object's monitor (the synchronized lock)-->
	<xsl:text>    global::System.Threading.Monitor.Enter(</xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:monitor-exit">
  <!-- We can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter in order
       to handle exceptions. Also, wait() and wait(long) need to be
       able to release the Object's monitor (the synchronized lock)-->
	<xsl:text>    global::System.Threading.Monitor.Exit(</xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:try-catch">
    <xsl:apply-templates select="dex:try"/>
    <xsl:apply-templates select="dex:catch"/>
    <xsl:if test="not(dex:catch)">
      <xsl:text>    catch (</xsl:text>
      <xsl:value-of select="$xmlvm-exception-type"/>
      <xsl:text> ex) {&nl;</xsl:text>
      <xsl:text>        global::System.Object _java_exception</xsl:text>
      <xsl:text> = ex.getJavaException();&nl;</xsl:text>
      <xsl:text>        if (_java_exception is </xsl:text>
      <xsl:value-of select="$xmlvm-red-type"/>
      <xsl:text>) {&nl;            </xsl:text>
      <xsl:text>// Red class exception catch removed&nl;</xsl:text>
      <xsl:text>            throw new </xsl:text>
      <xsl:value-of select="vm:get-type('org.xmlvm.NotYetImplementedException')"/>
      <xsl:text>(&quot;</xsl:text>
      <xsl:text>Red class exception removed</xsl:text>
      <xsl:text>&quot;);&nl;</xsl:text>
      <xsl:text>;&nl;        }&nl;</xsl:text>
      <xsl:text>        throw ex;&nl;</xsl:text>
      <xsl:text>    } // end catch&nl;</xsl:text>
    </xsl:if>
</xsl:template>


<xsl:template match="dex:try">
  <xsl:text>    try {&nl;</xsl:text>
  <xsl:apply-templates/>
  <xsl:text>    }&nl;</xsl:text>
</xsl:template>

<xsl:function name="vm:getExceptionRegister" as="xs:integer">
  <xsl:param name="root" as="node()"/>
  <xsl:param name="target" as="xs:integer"/>
  <xsl:value-of select="$root/descendant::dex:label[@id = $target]/following-sibling::dex:move-exception[position()=1]/@vx"/>
</xsl:function>

<xsl:template match="dex:catch">
  <xsl:if test="position()=1">
    <xsl:text>    catch (</xsl:text>
    <xsl:value-of select="$xmlvm-exception-type"/>
    <xsl:text> ex) {&nl;</xsl:text>
    <xsl:text>        global::System.Object _java_exception</xsl:text>
    <xsl:text> = ex.getJavaException();&nl;</xsl:text>
  </xsl:if>
  <xsl:text>        if (_java_exception is </xsl:text>
  <xsl:value-of select="vm:get-type(@exception-type)"/>
  <xsl:text>) {&nl;            _ex = ex;&nl;</xsl:text>
  <xsl:text>            goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;        }&nl;</xsl:text>
  <xsl:if test="position()=last()">
    <xsl:text>        throw ex;&nl;</xsl:text>
    <xsl:text>    } // end catch&nl;</xsl:text>
  </xsl:if>
</xsl:template>



<xsl:template match="dex:catches">
  <!-- do nothing -->
</xsl:template>


<xsl:template match="dex:throw">
	<xsl:text>    throw new </xsl:text>
	<xsl:value-of select="$xmlvm-exception-type"/>
	<xsl:text>((</xsl:text>
	<xsl:value-of select="vm:get-type(@vx-type)"/>
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:move-exception">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text> = _ex.getJavaException();&nl;    _ex = null;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int|dex:add-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:sub-int|dex:sub-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:mul-int|dex:mul-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-int|dex:div-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:rem-int|dex:rem-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> % </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:add-float|dex:add-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-float|dex:sub-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-float|dex:mul-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-float|dex:div-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-double|dex:add-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-double|dex:sub-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-double|dex:mul-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-double|dex:div-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-long|dex:add-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-long|dex:sub-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-long|dex:mul-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-long|dex:div-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-long|dex:rem-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> % </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:and-int-lit8|dex:and-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &amp; </xsl:text>
  <xsl:value-of select="@value"/>	
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:and-int|dex:and-int-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &amp; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:and-long|dex:and-long-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> &amp; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int-lit8">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &lt;&lt; (0x1f &amp; </xsl:text>
  <xsl:value-of select="@value"/>	
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int|dex:shl-int-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &lt;&lt; (0x1f &amp; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-long|dex:shl-long-2addr">
  <xsl:if test="not(@vx-type='long' 
		    and @vy-type='long' and @vz-type='int')">
    <!-- safety check -->
    <xsl:message>
      <xsl:text>unexpected types for dex:shl-long:&nl;</xsl:text>
      <xsl:value-of select="."/>
    </xsl:message>
  </xsl:if>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template> 
  <xsl:text> &lt;&lt; (0x3f &amp; </xsl:text>
  <xsl:if test="not(@vz-type='int')">
    <xsl:text>(int) </xsl:text>
  </xsl:if>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="@vz-type"/>
  </xsl:call-template> 
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-int-lit8">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &gt;&gt; (0x1f &amp; </xsl:text>
  <xsl:value-of select="@value"/>	
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-int|dex:shr-int-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> &gt;&gt; (0x1f &amp; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-long|dex:shr-long-2addr">
  <xsl:if test="not(@vx-type='long' 
		    and @vy-type='long' and @vz-type='int')">
    <!-- safety check -->
    <xsl:message>
      <xsl:text>unexpected types for dex:shr-long:&nl;</xsl:text>
      <xsl:value-of select="."/>
    </xsl:message>
  </xsl:if>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text> &gt;&gt; (0x3f &amp; </xsl:text>
  <xsl:if test="not(@vz-type='int')">
    <xsl:text>(int) </xsl:text>
  </xsl:if>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="@vz-type"/>
  </xsl:call-template> 
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-int-lit8">
  <xsl:if test="not(@vx-type='int' 
		    and @vy-type='int' and @vz-type='int')">
    <!-- safety check -->
    <xsl:message>
      <xsl:text>unexpected types for dex:ushr-int:&nl;</xsl:text>
      <xsl:value-of select="."/>
    </xsl:message>
  </xsl:if>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template> 
  <xsl:text> = (int) ((uint) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template> 
  <xsl:text>) &gt;&gt; (0x1f &amp; (</xsl:text>
  <xsl:if test="not(@vz-type='int')">
    <xsl:text>(int) </xsl:text>
  </xsl:if>
  <xsl:value-of select="@value"/>	
  <xsl:text>));&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-int|dex:ushr-int-2addr">
  <xsl:if test="not(@vx-type='int' 
		and @vy-type='int' and @vz-type='int')">
    <!-- safety check -->
    <xsl:message>
      <xsl:text>unexpected types for dex:ushr-int:&nl;</xsl:text>
      <xsl:value-of select="."/>
    </xsl:message>
  </xsl:if>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = (int) ((uint) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template> 
  <xsl:text>) &gt;&gt; (0x1f &amp; (</xsl:text>
  <xsl:if test="not(@vz-type='int')">
    <xsl:text>(int) </xsl:text>
  </xsl:if>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="@vz-type"/>
  </xsl:call-template> 
  <xsl:text>));&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-long|dex:ushr-long-2addr">
  <xsl:if test="not(@vx-type='long' 
		    and @vy-type='long' and @vz-type='int')">
    <!-- safety check -->
    <xsl:message>
      <xsl:text>unexpected types for dex:ushr-long:&nl;</xsl:text>
      <xsl:value-of select="."/>
    </xsl:message>
  </xsl:if>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template> 
  <xsl:text> = (long) ((ulong) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template> 
  <xsl:text>) &gt;&gt; (0x3f &amp; (</xsl:text>
  <xsl:if test="not(@vz-type='int')">
    <xsl:text>(int) </xsl:text>
  </xsl:if>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="@vz-type"/>
  </xsl:call-template> 
  <xsl:text>));&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:or-int-lit8|dex:or-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> | </xsl:text>
  <xsl:value-of select="@value"/>	
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-int|dex:or-int-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> | </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-long|dex:or-long-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> | </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int-lit8|dex:xor-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> ^ </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int|dex:xor-int-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text> ^ </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-long|dex:xor-long-2addr">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text> ^ </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:return-void">
  <xsl:text>    return;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:return|dex:return-wide|dex:return-object">
	<!-- TODO: fix this to catch exceptions a la csharp -->
	<xsl:if test="@catchesException = 'true'">
    	<xsl:text>    [_ex release];&nl;</xsl:text>
	</xsl:if>
	<xsl:variable name="return-type" select="ancestor::vm:method/vm:signature/vm:return/@type" />
	<xsl:text>    return </xsl:text>
	<xsl:if test="$return-type='byte' or $return-type='short' 
		      or $return-type='char' or vm:is-object-ref($return-type)">
	  <xsl:text>(</xsl:text>
	  <xsl:value-of select="vm:get-type($return-type)"/>
	  <xsl:text>) </xsl:text>
	</xsl:if>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx" />  
		<xsl:with-param name="type" select="$return-type" />  		
	</xsl:call-template>
	<xsl:if test="$return-type='boolean'">
	  <xsl:text>!=0</xsl:text>
	</xsl:if>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:new-instance">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text> = new </xsl:text>
	<xsl:value-of select="vm:get-type(@value)" />
	<xsl:text>();&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:iget|dex:iget-wide|dex:iget-boolean
		     |dex:iget-byte|dex:iget-char
		     |dex:iget-short|dex:iget-object">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@member-type"/>  	
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <!-- 
     no need to cast. 
     if it is object reference, the target register is System.Object.
     if it is sbyte, short or char, the target register is int
     only if it is boolean, we convert to int later
    -->
  <!--
     <xsl:text>(</xsl:text>
     <xsl:value-of select="vm:get-type(@member-type)" />	
     <xsl:text>) </xsl:text>
     -->
  <xsl:text>((</xsl:text>
  <xsl:value-of select="vm:get-type(@class-type)" />
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>  	
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:value-of select="vm:get-member-name(@member-name,true())"/>
  <xsl:if test="@member-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:iput|dex:iput-wide|dex:iput-boolean
		     |dex:iput-byte|dex:iput-char
		     |dex:iput-short|dex:iput-object">
  <xsl:text>    ((</xsl:text>
  <xsl:value-of select="vm:get-type(@class-type)" />
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>  	
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:value-of select="vm:get-member-name(@member-name,true())"/>
  <xsl:text> = </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:is-object-ref(@member-type) or @member-type='byte' 
		    or @member-type='short' or @member-type='char'">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="vm:get-type(@member-type)" />	
      <xsl:text>) </xsl:text>
    </xsl:when>
    <xsl:when test="@member-type='boolean'">
      <xsl:text>0!=</xsl:text>
    </xsl:when>
  </xsl:choose>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@member-type"/>  	
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sget|dex:sget-wide|dex:sget-boolean|dex:sget-byte
		     |dex:sget-char|dex:sget-short|dex:sget-object">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@member-type"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <!-- no need to cast! -->
  <xsl:value-of select="vm:get-type(@class-type)" />
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:get-member-name(@member-name,true())"/>
  <xsl:if test="@member-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:sput|dex:sput-wide|dex:sput-boolean|dex:sput-byte
		     |dex:sput-char|dex:sput-short|dex:sput-object">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:get-type(@class-type)" />
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:get-member-name(@member-name,true())"/>
  <xsl:text> = </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:is-object-ref(@member-type) or @member-type='byte' 
		    or @member-type='short' or @member-type='char'">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="vm:get-type(@member-type)" />	
      <xsl:text>) </xsl:text>
    </xsl:when>
    <xsl:when test="@member-type='boolean'">
      <xsl:text>0!=</xsl:text>
    </xsl:when>
  </xsl:choose>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@member-type"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>



<xsl:template match="dex:const-4[@kind='known-null']|dex:const-8[@kind='known-null']|dex:const-16[@kind='known-null']"> 
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
    <xsl:text> = null;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:const|dex:const-4|dex:const-16|dex:const-wide|dex:const-wide-16|dex:const-wide-32|dex:const-high16|dex:const-wide-high16"> 
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@type"/>
  </xsl:call-template> 
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:get-reg-value(@value,@type)"/>
  <xs:text>;&nl;</xs:text>
</xsl:template>

<xsl:function name="vm:octToHex" as="xs:string">
  <xsl:param name="oct" as="xs:string"/>
  <xsl:variable name="prefix-length" as="xs:integer" select="fn:string-length($oct)*3 mod 4"/>
  <xsl:variable name="prefix-sequence" as="xs:string*">
    <xsl:for-each select="1 to $prefix-length">
      <xsl:value-of select="'0'"/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:variable name="bits" as="xs:string"
		select="fn:concat(fn:string-join($prefix-sequence,''),
			          fn:replace(
				  fn:replace(
				  fn:replace(
				  fn:replace(
				  fn:replace(
				  fn:replace(
				  fn:replace(
				  fn:replace($oct, '0', '000'),
				  '1', '001'),
				  '2', '010'),
				  '3', '011'),
				  '4', '100'),
				  '5', '101'),
				  '6', '110'),
				  '7', '111'))"/>
  <xsl:variable name="hexSequence" as="xs:string*">
    <xsl:for-each select="1 to (fn:string-length($bits) idiv 4)">
      <xsl:variable name="decVal" as="xs:integer" 
		    select="8*xs:integer(fn:substring($bits,position()*4-3,1))
			    +4*xs:integer(fn:substring($bits,position()*4-2,1))
			    +2*xs:integer(fn:substring($bits,position()*4-1,1))
			    +xs:integer(fn:substring($bits,position()*4,1))"/>
      <xsl:sequence select="fn:substring('0123456789ABCDEF',$decVal+1, 1) "/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:value-of select="fn:string-join($hexSequence,'')"/>
</xsl:function>

<!-- 
   the following assumes that the given octal string
   represents a 16-bit hexadecimal
-->
<xsl:function name="vm:octTo04x" as="xs:string">
  <xsl:param name="oct" as="xs:string"/>
  <xsl:variable name="hexStr" as="xs:string" select="vm:octToHex($oct)"/>
  <xsl:value-of select="fn:substring($hexStr,fn:string-length($hexStr)-4+1,4)"/>
</xsl:function>

<xsl:function name="vm:xmlvmToUnicode" as="xs:string">
  <xsl:param name="xmlvmStr" as="xs:string"/>
  <xsl:variable name="resultSequence" as="xs:string*">
    <xsl:for-each select="fn:tokenize($xmlvmStr,'\\')">
      <!--<xsl:sequence select="vm:nonexisting()"/> -->
      <xsl:sequence select="if (position()=1)
			      then .
			      else fn:concat('\u', 
			                     vm:octTo04x(fn:substring(.,1,6)), 
					     if (fn:string-length(.) gt 6)
					       then fn:substring(.,7)
					       else '')"/>
    </xsl:for-each>
  </xsl:variable>
  <xsl:value-of select="fn:string-join($resultSequence, '')"/>
</xsl:function>

<!-- following helper function is inspired by xmlvm2c.xsl -->
<xsl:function name="vm:escape-string">
  <xsl:param  name="string"/> 
  <!-- Escape all \\ \t(011) \n(012) \r(015) \f(014) \b(010) \" -->
  <!-- Single quotes don't need to be escaped. -->
  <xsl:text>"</xsl:text>

  <xsl:value-of select="replace(replace(replace(replace(replace(replace(replace(
			vm:xmlvmToUnicode($string),
			'\\u0009','\\t'),
			'\\u000A','\\n'),
			'\\u000D','\\r'),
			'\\u000C','\\f'),
			'\\u0008','\\b'),
			'\\u0022','\\&quot;'),
			'\\u005C','\\\\')"/>
<!--  
  <xsl:value-of select="replace(replace(replace(replace(replace(replace(replace(
			replace($string, '\\(\d{3})(\d{3})',fn:concat('\\u', vm:octTo02x($1),vm:octTo02x($2))),
			'\\000011','\\t'),
			'\\000012','\\n'),
			'\\000015','\\r'),
			'\\000014','\\f'),
			'\\000010','\\b'),
			'\\000042','\\&quot;'),
			'\\000134','\\\\')"/>
-->
  <xsl:text>"</xsl:text>
</xsl:function>


<xsl:template match="dex:const-string">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emit-register-name">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text> = new </xsl:text>
	<xsl:value-of select="vm:get-type('java.lang.String')"/>
	<xsl:text>();&nl;</xsl:text>
	<xsl:text>    ((</xsl:text>
	<xsl:value-of select="vm:get-type('java.lang.String')"/>
	<xsl:text>)</xsl:text> <!-- " -->
	<xsl:call-template name="emit-register-name"> 
		<xsl:with-param name="num" select="@vx"/> 
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text>).</xsl:text>
	<xsl:value-of select="fn:concat($init,'(new ',vm:get-xmlvm-array('char'))"/>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="vm:escape-string(@value)"/>
	<xsl:text>.ToCharArray()));&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:const-class"> 
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = typeof(</xsl:text>
  <xsl:value-of select="vm:get-type(@value)"/>
  <xs:text>);&nl;</xs:text>
</xsl:template>




<xsl:template match="dex:int-to-byte">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> &lt;&lt; 24) &gt;&gt; 24;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-char">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> &amp; 0xffff;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-short">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> &lt;&lt; 16) &gt;&gt; 16;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-long">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text> = (long) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-float">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text> = (float) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-double">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text> = (double) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-int">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = (int) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-float">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text> = (float) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-double">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text> = (double) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-int">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = (int) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-long">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text> = (long) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-double">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text> = (double) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-int">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = (int) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-float">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text> = (float) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-long">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text> = (long) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmp-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-int">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = -</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-long">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text> = -</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-float">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text> = -</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'float'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-double">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text> = -</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'double'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:not-int">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = ~</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:not-long">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text> = ~</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'long'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int-lit8|dex:add-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> + </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-int-lit8|dex:mul-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> * </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-int-lit8|dex:div-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> / </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-int-lit8|dex:rem-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> % </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:goto|dex:goto-16">
  <xsl:text>    goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eqz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:is-object-ref(@vx-type)">
      <xsl:text>null</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-nez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:is-object-ref(@vx-type)">
      <xsl:text>null</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ltz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gtz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ge">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gt">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-le">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lt">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eq">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ne">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sparse-switch|dex:packed-switch">
  <xsl:text>    switch (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i) {
</xsl:text>
  <xsl:for-each select="dex:case">
    <xsl:text>    case </xsl:text>
    <xsl:value-of select="@key"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;
</xsl:text>
  </xsl:for-each>
  <xsl:text>    }
</xsl:text>
</xsl:template>

<!-- ******************* Begin Arrays ******************************** -->

<xsl:function name="vm:get-array-base-type" as="xs:string">
  <xsl:param name="arrayType" as="xs:string" />
  <xsl:value-of select="fn:substring($arrayType, 1, 
			             fn:string-length($arrayType) - 2)"/>
</xsl:function>

<xsl:function name="vm:get-xmlvm-array" as="xs:string">
  <xsl:param name="base-type"/>
  <xsl:value-of select="fn:concat($xmlvm-array-type,
			          '&lt;',
				  if (vm:is-object-ref($base-type))
				    then $obj-regtype
				    else vm:get-type($base-type),
				  '&gt;')"/>
</xsl:function>

<xsl:template name="emit-new-array">
  <xsl:param name="arrayInitializer" as="xs:string"/>
  <xsl:param name="base-type" as="xs:string"/>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = new </xsl:text>
  <xsl:value-of select="vm:get-xmlvm-array($base-type)"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="fn:concat('new ', 
			          if (vm:is-object-ref($base-type))
				    then $obj-regtype
				    else vm:get-type($base-type),
				  $arrayInitializer)"/>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:new-array">
  <xsl:variable name="base-type" select="vm:get-array-base-type(@value)"/>
  <xsl:variable name="arrayInitializer">
    <xsl:text>[</xsl:text>
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="@vy"/>
      <xsl:with-param name="type" select="'int'"/>
    </xsl:call-template>
    <xsl:text>]</xsl:text>
  </xsl:variable>
  <xsl:call-template name="emit-new-array">
    <xsl:with-param name="arrayInitializer" select="$arrayInitializer"/>
    <xsl:with-param name="base-type" select="$base-type"/>
  </xsl:call-template>
</xsl:template>


<xsl:template match="dex:aget|dex:aget-wide|dex:aget-boolean
		     |dex:aget-byte|dex:aget-char|dex:aget-short">
  <xsl:variable name="base-type" as="xs:string"
		select="vm:get-array-base-type(@vy-type)"/>
  <xsl:text>    </xsl:text>
  <!-- destination -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:text>((</xsl:text>
  <xsl:value-of select="vm:get-xmlvm-array($base-type)"/>
  <xsl:text>) </xsl:text>
  <!-- array reference -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>get</xsl:text>
  <xsl:text>(</xsl:text>
  <!-- index -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:if test="$base-type='boolean'">
    <xsl:text> ? 1 : 0</xsl:text>
  </xsl:if>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:aget-object">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:value-of select="vm:get-xmlvm-array(vm:get-array-base-type('obj'))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>get</xsl:text>
  <xsl:text>(</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:aput|dex:aput-wide|dex:aput-boolean
		     |dex:aput-char|dex:aput-byte|dex:aput-short">
  <xsl:variable name="base-type" as="xs:string"
		select="vm:get-array-base-type(@vy-type)" />
  <xsl:text>    ((</xsl:text>
  <xsl:value-of select="vm:get-xmlvm-array($base-type)"/>
  <xsl:text>) </xsl:text>
  <!-- array reference -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>set</xsl:text>
  <xsl:text>(</xsl:text>
  <!-- source (new value) -->
  <xsl:choose> 
    <!-- casting if needed-->
    <xsl:when test="$base-type='byte' or $base-type='short' or $base-type='char'">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="vm:get-type($base-type)"/>
      <xsl:text>)</xsl:text>
    </xsl:when>
    <xsl:when test="$base-type='boolean'">
      <xsl:text>0!=</xsl:text>
    </xsl:when>
  </xsl:choose>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text>, </xsl:text>
  <!-- index -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:aput-object">
  <xsl:text>    ((</xsl:text>
  <xsl:value-of select="vm:get-xmlvm-array(vm:get-array-base-type('obj'))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>set</xsl:text>
  <xsl:text>(</xsl:text>
  <!-- new value -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>, </xsl:text>
  <!-- index -->
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:array-length">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:value-of select="$xmlvm-array-interface"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).getLength();&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:fill-array-data">
  <xsl:variable name="base-type" select="vm:get-array-base-type(@vx-type)"/>
  <xsl:variable name="arrayInitializer">
    <xsl:text>[]{</xsl:text>
    <xsl:for-each select="dex:constant">
      <xsl:value-of select="vm:get-native-value(@value,$base-type)"/>
      <xsl:if test="not(position()=last())">
	<xsl:text>, </xsl:text>
      </xsl:if>
    </xsl:for-each>
    <xsl:text>}</xsl:text>
  </xsl:variable>
  <xsl:call-template name="emit-new-array">
    <xsl:with-param name="arrayInitializer" select="$arrayInitializer"/>
    <xsl:with-param name="base-type" select="$base-type"/>
  </xsl:call-template>
</xsl:template>


<!--
<xsl:template match="dex:filled-new-array|dex:filled-new-array-range">
  <xsl:variable name="base-type" select="vm:get-array-base-type(@value)"/>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = (id) ((XMLVMElem[]) {</xsl:text>
  <xsl:for-each select="dex:value">
    <xsl:call-template name="emit-register-name">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="$base-type"/>
    </xsl:call-template>
    <xsl:text>, </xsl:text>
  </xsl:for-each>
  <xsl:text>});&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = [XMLVMArray createSingleDimensionWithType:</xsl:text>
  <xsl:value-of select="vm:typeID($base-type)"/>
  <xsl:text> size:</xsl:text>
  <xsl:value-of select="count(dex:value)"/>
  <xsl:text> andData:_r</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>];&nl;</xsl:text>
</xsl:template>
-->



<!-- ******************* End Arrays ******************************** -->


<xsl:template match="dex:check-cast">
  <!-- TODO should do a runtime type check -->
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:instance-of">
  <!-- 
     @value = actual type
     @vy-type = apparent type
     @vy = object reference
     @vx = result (boolean)
  -->
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text> != null) &amp;&amp; (</xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text> is </xsl:text>
  <xsl:value-of select="vm:get-type(@value)"/>
  <xsl:text>)) ? 1 : 0;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:move|dex:move-from16|dex:move-wide|dex:move-wide-from16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:move-object|dex:move-object-from16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emit-register-name">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="vm:assert-red-class">
  <xsl:text>// Red class access removed: </xsl:text>
  <xsl:value-of select="@type"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="@member"/>
  <xsl:text>&nl;</xsl:text>
  <xsl:text>throw new </xsl:text>
  <xsl:value-of select="vm:get-type('org.xmlvm.NotYetImplementedException')"/>
  <xsl:text>(&quot;</xsl:text>
  <xsl:text>Red class access removed: </xsl:text>
  <xsl:value-of select="@type"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="@member"/>
  <xsl:text>&quot;);&nl;</xsl:text>
</xsl:template>


<!--
   Default template. If the XMLVM file should contain an instruction
   that is not handled by this stylesheet, this default template
   will make sure we notice it by writing a special error function
   to the output stream.
-->
<xsl:template match="*">
  <xsl:text>      throw new </xsl:text>
  <xsl:value-of select="vm:get-type('org.xmlvm.NotYetImplementedException')"/>
  <xsl:text>(&quot;</xsl:text>
  <xsl:value-of select="name()"/>
  <xsl:text>&quot;);&nl;</xsl:text>
  <xsl:message select="."/>
</xsl:template>


</xsl:stylesheet>
