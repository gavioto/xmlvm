<?xml version="1.0"?>

<!DOCTYPE xsl:stylesheet [
<!ENTITY nl "&#xa;"><!--new line-->
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs = "http://www.w3.org/2001/XMLSchema"
                xmlns:fn = "http://www.w3.org/2005/xpath-functions"
                xmlns:vm ="http://xmlvm.org"
                xmlns:jvm="http://xmlvm.org/jvm"
                xmlns:dex="http://xmlvm.org/dex"
                version="2.0">

<xsl:output method="text" indent="no"/>

<!-- get this from CSharpOutputProcess -->
<xsl:param name="genWrapper" select="'false'"/>
<xsl:param name="csharpConvention" select="'false'"/>

<xsl:variable name="nl" select="xs:string('&#xa;')"/> <!-- new line -->        

<xsl:param name="clinit" select="'@static'"/>
<xsl:param name="init" select="'@this'"/>

<xsl:param name="nonobj_regtype" select="$xmlvmElementType"/>
<xsl:param name="obj_regtype" select="'global::System.Object'"/>
<xsl:param name="regname" select="'_r'"/>
<xsl:param name="nonobj_regname_suffix" select="''"/>
<xsl:param name="obj_regname_suffix" select="'_o'"/>

<xsl:param name="xmlvmExceptionType" select="vm:getType('org.xmlvm.Exception')"/>
<xsl:param name="xmlvmElementType" select="vm:getType('org.xmlvm.Element')"/>
<xsl:param name="xmlvmArrayType" select="vm:getType('org.xmlvm.Array')"/>
<xsl:param name="xmlvmArrayInterface" select="vm:getType('org.xmlvm.IArray')"/>

<!-- TODO: change to 'X' or some other capital, to support csharp convention -->
<xsl:param name="public_member_prefix" select="''"/> 
<!-- TODO: change to '_', to support csharp convention -->
<xsl:param name="private_member_prefix" select="''"/> 


<!-- TODO: update this to all csharp keywords -->
<xsl:param name="keywords" select="('out', 'abstract')" as="xs:string*"/>

<!-- main template -->
<xsl:template match="vm:xmlvm">
	<xsl:text>&nl;// Automatically generated by xmlvm2csharp. </xsl:text>
	<xsl:text>Do not edit!&nl;</xsl:text> 
	<xsl:text>&nl;using </xsl:text>
	<xsl:value-of select="vm:getType('org.xmlvm')"/>
	<xsl:text>;&nl;using </xsl:text>
	<xsl:value-of select="vm:getType('java')"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="vm:getType('org.xmlvm.java')"/>
	<xsl:text>;&nl;</xsl:text> 	
	<xsl:for-each select="vm:class">
		<xsl:if test="not($genWrapper='true' and @isPrivate='true')">
			<xsl:call-template name="emitNamespace"/>
		</xsl:if>
	</xsl:for-each> 
</xsl:template>

<xsl:template name="emitMainMethod">
        <xsl:param name="override" select="'false'"/>
	<xsl:text>&nl;public static </xsl:text>
	<xsl:if test="$override='true'">
	  <xsl:text>new </xsl:text>
	</xsl:if>
	<xsl:text>void Main(global::System.String[] args) {&nl;</xsl:text>
	<xsl:text>    // first convert to java strings, then call main():&nl;</xsl:text>
	<xsl:text>    java.lang.String[] jargs = null;&nl;</xsl:text>
	<xsl:text>    if (args != null) {&nl;</xsl:text>
	<xsl:text>        jargs = new java.lang.String[args.Length];&nl;</xsl:text>
	<xsl:text>        for (int i=0; i&lt;args.Length; i++) {&nl;</xsl:text>
	<xsl:text>            jargs[i] = new java.lang.String(args[i]);&nl;</xsl:text>
	<xsl:text>        }&nl;</xsl:text>
	<xsl:text>    }&nl;</xsl:text>
	<xsl:text>    </xsl:text>
	<xsl:value-of select="vm:getPublicMemberName('main')"/>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="fn:concat('new ', $xmlvmArrayType, 
			                '&lt;', 
					$obj_regtype, 
					'&gt;', '(jargs)')"/>
	<xsl:text>);&nl;    return;&nl;}&nl;&nl;</xsl:text>
</xsl:template>

<xsl:template name="emitStaticConstructor">
	<xsl:param name="name" />
	<xsl:text>&nl;static </xsl:text>
	<xsl:value-of select="vm:getClassName($name)"/>
	<xsl:text>() {&nl;    </xsl:text>
	<xsl:value-of select="$clinit" />
	<xsl:text>();&nl;}&nl;&nl;</xsl:text>
</xsl:template>


<xsl:template name="emitNamespace">
	<xsl:variable name="namespace" select="vm:getNamespace(@package)"/>
	<xsl:choose>
		<xsl:when test="$namespace and not($namespace='')">
			<xsl:text>namespace </xsl:text>
			<xsl:value-of select="$namespace"/>
			<xsl:text> {&nl;</xsl:text>
			<xsl:call-template name="emitClass">
				<xsl:with-param name="namespace" select="$namespace"/>
			</xsl:call-template>
			<xsl:text>} // end of namespace: </xsl:text>
			<xsl:value-of select="$namespace"/>
			<xsl:text>&nl;</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="emitClass"/>		
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template name="emitClass">
	<xsl:param name="namespace" as="xs:string" select="''"/>
	<xsl:variable name="className" select="vm:getClassName(@name)"/>		  
	<!-- step 1: (modifier)* (interface | class) (ClassName) : (ParentType) "{" -->  
  	<xsl:value-of select="fn:string-join(vm:getModifiers(.),' ')"/>
  	<xsl:text> </xsl:text>
  	<xsl:choose>
  		<xsl:when test="@isInterface = 'true'">
  			<xsl:text>interface </xsl:text>
  		</xsl:when>
  		<xsl:otherwise>
      		<xsl:text>class </xsl:text>
  		</xsl:otherwise>
	</xsl:choose>  	
	<xsl:value-of select="$className"/>
	<xsl:variable name="csParents" as="xs:string*">
	    <xsl:for-each select="if ((@package='org.xmlvm.java.lang' 
				      and @name='Object') or (@isInterface='true'))
				    then fn:tokenize(@interfaces, ',')
				    else fn:insert-before(fn:tokenize(@interfaces, ','), 
				                          1, @extends)">
	      <xsl:sequence select="vm:getType(.)"/>
	    </xsl:for-each>
	</xsl:variable>
	<xsl:value-of select="if (exists($csParents))
			      then fn:concat(': ', fn:string-join($csParents, ','))
			      else ''"/>
<!--	
    <xsl:if test="@extends and @extends!='' and not($namespace=vm:getNamespace('org.xmlvm.java.lang') and $className=vm:getType('Object'))" >
      
    	<xsl:text> : </xsl:text>
    	<xsl:value-of select="vm:getType(@extends)" />
    </xsl:if>
-->
    <xsl:text> {&nl;</xsl:text>
    
    <!-- step 2a: emit Main() if needed -->
    <xsl:if test="vm:method/@name = 'main'">
      <xsl:choose>
        <xsl:when test="vm:method[@name='main']/@isOverride='true'">
    	  <xsl:call-template name="emitMainMethod">
	    <xsl:with-param name="override" select="'true'"/>
	  </xsl:call-template>
	</xsl:when>
	<xsl:otherwise>
    	  <xsl:call-template name="emitMainMethod">
	    <xsl:with-param name="override" select="'false'"/>
	  </xsl:call-template>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <!-- 
    	step 2b: emit a csharp static constructor if needed 
    	(e.g. java code contained static initialization block 
    -->
    <xsl:if test="vm:method/@name = '&lt;clinit&gt;'">
    	<xsl:call-template name="emitStaticConstructor">
    		<xsl:with-param name="name" select="@name"/>
    	</xsl:call-template>
    </xsl:if>
  
    <!-- step 3: emit variable definition for all fields (both static and non-static) -->
    <xsl:for-each select="vm:field">
      <xsl:if test="not($genWrapper='true' and @isPrivate='true')">
    	<xsl:value-of select="fn:string-join(vm:getModifiers(.),' ')" />
      	<xsl:text> </xsl:text>    		    
      	<xsl:value-of select="vm:getType(@type)" />
      	<xsl:text> </xsl:text>
 	<xsl:value-of select="vm:getMemberNodeName(.)"/>
      	<xsl:if test="@value">
          <xsl:text> = </xsl:text>
	  <xsl:choose>
	    <xsl:when test="@type = 'java.lang.String'">
	      <xsl:text>new </xsl:text>
	      <xsl:value-of select="vm:getType('java.lang.String')"/>
	      <xsl:text>(</xsl:text>
	      <xsl:value-of select="vm:escapeString(@value)"/>
	      <xsl:text>)</xsl:text>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="@value"/>
	      <xsl:choose>
		<xsl:when test="@type='float'">
		  <xsl:text>f</xsl:text>
		</xsl:when>
		<xsl:when test="@type='double'">
		  <xsl:text>d</xsl:text>
		</xsl:when>
		<xsl:when test="@type='long'">
		  <xsl:text>l</xsl:text>
		</xsl:when>
	      </xsl:choose>
	    </xsl:otherwise>
	  </xsl:choose>
      	</xsl:if>
    	<xsl:text>;&nl;&nl;</xsl:text>
      </xsl:if>
    </xsl:for-each>
    
    <!-- step 4: emit methods -->
    <xsl:for-each select="vm:method">
      <xsl:if test="not(vm:isDuplicateMethod(.)) 
		    and not($genWrapper='true' and @isPrivate='true')">
      	<xsl:value-of select="fn:string-join(vm:getModifiers(.),' ')"/>
      	<xsl:text> </xsl:text>
      	<xsl:if test="not(@isStatic and @isStatic='true') 
      		      and not(@isPrivate and @isPrivate='true') 
      		      and not(@isFinal and @isFinal='true')
		      and not(@name='&lt;init&gt;')">
	  <xsl:choose>
	    <xsl:when test="@isOverride and @isOverride='true'">
	      <xsl:text>override </xsl:text>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:if test="not(../@isInterface='true' or @isAbstract='true')">
		<xsl:text>virtual </xsl:text>
	      </xsl:if>
	    </xsl:otherwise>
	  </xsl:choose>
      	</xsl:if>
	<xsl:if test="@isOverride='true' 
      		      and not(@isPrivate and @isPrivate='true') 
		      and ((@isStatic and @isStatic='true') 
		      or (@isFinal and @isFinal='true') 
		      or (@name='&lt;init&gt;'))">
	  <xsl:text>new </xsl:text>
	</xsl:if>
        <xsl:value-of select="vm:getMethodSignature(.)"/>
	<xsl:choose>
    	  <xsl:when test="../.[@isInterface = 'true'] or @isAbstract = 'true'">
            <xsl:text>;&nl;&nl;</xsl:text>
          </xsl:when>
	  <xsl:otherwise>
	    <xsl:text>{&nl;</xsl:text>
	    <xsl:choose>
	      <xsl:when test="$genWrapper='true' or @isNative='true'">
		<xsl:call-template name="emitWrapperComments">
		  <xsl:with-param name="member" select="vm:getMethodSignature(., false())"/>
		  <xsl:with-param name="package" select="../@package"/>
		  <xsl:with-param name="class" select="../@name"/>
		</xsl:call-template>
	      </xsl:when>
	      <xsl:otherwise>
		<xsl:call-template name="initArguments" />
		<xsl:apply-templates/>
	      </xsl:otherwise>
	    </xsl:choose>
	    <xsl:text>}&nl;&nl;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    
    <!-- step 5: end of class implementation -->
    <xsl:if test="$genWrapper='true'">
      <xsl:call-template name="emitWrapperComments">
    	<xsl:with-param name="member" select="''"/>
    	<xsl:with-param name="package" select="@package"/>
    	<xsl:with-param name="class" select="@name"/>    		    		
      </xsl:call-template>
    </xsl:if>
    <xsl:text>&nl;} // end of class: </xsl:text>
    <xsl:value-of select="$className"/>
    <xsl:text>&nl;&nl;</xsl:text>
</xsl:template> <!-- end of template: emitClass -->


<xsl:template match="vm:signature">
  <!-- Do nothing -->
</xsl:template>

<!-- converts the given java type to csharp -->
<xsl:function name="vm:getType" as="xs:string">
  <xsl:param name="jType" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="$jType = 'void'">
      <xsl:value-of select="'void'" />
    </xsl:when>
    <xsl:when test="$jType = 'char'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="$jType = 'byte'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="$jType = 'short'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="$jType = 'int'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="$jType = 'long'">
      <xsl:value-of select="'long'" />
    </xsl:when>
    <xsl:when test="$jType = 'float'">
      <xsl:value-of select="'float'" />
    </xsl:when>
    <xsl:when test="$jType = 'double'">
      <xsl:value-of select="'double'" />
    </xsl:when>
    <xsl:when test="$jType = 'boolean'">
      <xsl:value-of select="'int'" />
    </xsl:when>
    <xsl:when test="ends-with($jType, '[]')">
      <xsl:variable name="baseType" select="vm:getArrayBaseType($jType)"/>
      <xsl:value-of select="fn:concat($xmlvmArrayType,
			              '&lt;', 
				      if (vm:isObjectRef($baseType))
				        then $obj_regtype
					else $baseType,
				      '&gt;')" />
      
    </xsl:when>
    <xsl:otherwise>
    	<xsl:variable name="csTypes" as="xs:string*">
    		<xsl:for-each select="fn:tokenize($jType,'\.')">
   				<xsl:sequence select="if (position()=last()) 
   							then vm:getClassName(.) 
   							else vm:getNamespace(.)"/>
    		</xsl:for-each>
    	</xsl:variable>
	<xsl:value-of select="fn:string-join($csTypes,'.')"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<!-- 
	switches lower to upper case at the beginning of a given word
	and vice versa 
-->
<xsl:function name="vm:switchCapitalization" as="xs:string">
	<xsl:param name="word" as="xs:string"/>
	<xsl:variable name="letter" select="fn:substring($word, 1, 1)"/>
	<xsl:variable name="upperCase" select="fn:upper-case($letter)"/>
	<xsl:variable name="lowerCase" select="fn:lower-case($letter)"/>
	<xsl:choose>
		<xsl:when test="$upperCase=$letter">
			<xsl:value-of select="fn:concat($lowerCase, fn:substring($word,2))"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="fn:concat($upperCase, fn:substring($word,2))"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:function>


<!-- checks whether the given string is a csharp reserved word -->
<xsl:function name="vm:isKeyword" as="xs:boolean">
	<xsl:param name="word" as="xs:string"/>
	<xsl:value-of select="$keywords=$word"/>
</xsl:function>


<!-- 
   1. escapes csharp reserved words with @,
   2. converts <init> and <clinit> into $init and $clinit repectively 
   3. escapes '$'
   4. prefixes private/public names according to global variables/convention
-->
<xsl:function name="vm:getMemberName" as="xs:string">
  <xsl:param name="name" as="xs:string"/>
  <xsl:param name="isPublic" as="xs:boolean"/>
  <!-- 
     the following code escapes dollars in java names 
     without nameclashes using the one-to-one transformation:
     '_' to '_1'
     '$' to '_2'
     note: of course it is important to transform '_' first...
  -->
  <xsl:variable name="dollarEscapedName" as="xs:string" 
		select="fn:replace(fn:replace($name, '_', '_1'), '\$', '_2')"/>

  <xsl:choose>
    <xsl:when test="$name = '&lt;init&gt;'">
      <xsl:value-of select="$init" />
    </xsl:when>
    <xsl:when test="$name = '&lt;clinit&gt;'">
      <xsl:value-of select="$clinit" />
    </xsl:when>
    <xsl:when test="$name = 'finalize'">
      <xsl:value-of select="'@final'" />
    </xsl:when>
    <xsl:when test="vm:isKeyword($name)">
      <xsl:value-of select="concat('@',$name)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="if ($isPublic) 
      			      then fn:concat($public_member_prefix, 
			                     $dollarEscapedName)
      			      else fn:concat($private_member_prefix, 
			                     $dollarEscapedName)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<!-- 
	converts a given class name to csharp's convention
	ASSUMPTION: given class name follows java's convention
	TODO 1: remove assumption
	TODO 2: escape keywords?
-->
<xsl:function name="vm:getClassName" as="xs:string">
	<xsl:param name="name" as="xs:string"/>
	<xsl:value-of select="vm:getPublicMemberName($name)"/>
</xsl:function>

<!-- 
   converts a given public member name to csharp's convention
-->
<xsl:function name="vm:getPublicMemberName" as="xs:string">
	<xsl:param name="name" as="xs:string"/>
	<xsl:value-of select="vm:getMemberName($name, true())"/>
</xsl:function>

<!-- 
   converts a given private/protected member name to csharp's convention 
-->
<xsl:function name="vm:getPrivateMemberName" as="xs:string">
	<xsl:param name="name" as="xs:string"/>
	<xsl:value-of select="vm:getMemberName($name, false())"/>
</xsl:function>

<!-- returns the name of the given member node accoding to csharp's convention -->
<xsl:function name="vm:getMemberNodeName" as="xs:string">
	<xsl:param name="memberNode" as="node()"/>
	<!-- note: the following else clause covers package-scope (no attribute)-->
	<xsl:value-of select="if ($memberNode/@isPrivate='true' 
			          or $memberNode/@isProtected='true')
				then vm:getPrivateMemberName($memberNode/@name)
				else vm:getPublicMemberName($memberNode/@name)"/>
</xsl:function>

<!-- 
	converts a given package name to csharp namespace convention
	ASSUMPTION: given package name follows java's convention
	TODO: change recursion to a loop over tokenize(...) 
	TODO 2: escape csharp keywords
	TODO 3: remove assumption
-->
<xsl:function name="vm:getNamespace" as="xs:string">
	<xsl:param name="pkgName" as="xs:string"/>
	<xsl:choose>
		<xsl:when test="not($pkgName) or $pkgName=''">
			<xsl:value-of select="''"/> 
		</xsl:when>
		<xsl:when test="not(fn:contains($pkgName,'.'))">
			<xsl:value-of select="if ($csharpConvention='true')
					      then vm:switchCapitalization($pkgName)
					      else $pkgName"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="car" select="fn:substring-before($pkgName, '.')"/>
			<xsl:variable name="cdr" select="fn:substring-after($pkgName, '.')"/>			
			<xsl:value-of 
				select="fn:concat(if ($csharpConvention='true')
					then vm:switchCapitalization($car)
					else $car,
					'.', vm:getNamespace($cdr))"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:function>



<!-- 
	returns a fully qualified name of the given node 
	in the form "package.class.member" 
-->
<xsl:function name="vm:getMemberFullName" as="xs:string">
	<xsl:param name="memberNode" as="node()"/>
	<xsl:variable name="currName" select="$memberNode/@name"/>
	<xsl:variable name="currPkg" select="$memberNode/@package"/>
	<xsl:variable name="result" as="xs:string*">
		<xsl:choose>
			<xsl:when test="not($currPkg) or $currPkg=''">
				<!-- no package attribute or a trivial package attribute -->
				<xsl:variable name="parentName" select="$memberNode/../@name"/>
				<xsl:variable name="parentPkg" select="$memberNode/../@package"/>	
				<xsl:choose>
					<xsl:when test="not($parentPkg) or $parentPkg=''">
						<!-- no package for parent or it's a trivial package attribute -->
						<xsl:choose>
							<xsl:when test="not($parentName) or $parentName=''">
								<!-- no name for parent. name it simply CurrentName -->
							</xsl:when>
							<xsl:otherwise>
								<!-- name it by the parent with no package: Parent.Current -->
								<xsl:sequence select="vm:getClassName($parentName)"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<!-- package exists for parent. name it ParentPkg.Parent.Current -->
						<xsl:sequence select="vm:getNamespace($parentPkg)"/>
						<xsl:sequence select="vm:getClassName($parentName)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<!-- package exists for current. name it Package.Current -->
				<xsl:sequence select="vm:getNamespace($currPkg)"/>
			</xsl:otherwise>
		</xsl:choose>  	
    	<xsl:sequence select="vm:getMemberNodeName($memberNode)"/>
    </xsl:variable>
    <xsl:value-of select="fn:string-join($result,'.')" />
</xsl:function>


<!-- get the modifiers of the given node -->
<xsl:function name="vm:getModifiers" as="xs:string*">
	<xsl:param name="memberNode" as="node()"/>
	<xsl:if test="not($memberNode/../@isInterface='true')">
	  <xsl:choose>
	    <xsl:when test="$memberNode/@isPublic = 'true'">
    	      <xsl:sequence select="'public'"/>
	    </xsl:when>
	    <xsl:when test="$memberNode/@isPrivate = 'true'">
    	      <xsl:sequence select="'private'"/>
	    </xsl:when>	
	    <xsl:when test="$memberNode/@isProtected = 'true'">
    	      <xsl:sequence select="'protected'"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <!-- package-scope -->
	      <xsl:sequence select="'public'"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:if>
	<xsl:if test="$memberNode/@isStatic = 'true'">
	  <xsl:sequence select="'static'"/>
	</xsl:if>
	<xsl:if test="$memberNode/@isAbstract = 'true' 
		        and not($memberNode/../@isInterface='true')
			and not($memberNode/@isInterface='true')">
    	  <xsl:sequence select="'abstract'"/>
	</xsl:if>
</xsl:function>

<!-- 
	returns the csharp signature of the given method node 
	as "returnType methodName (type n1, type n2, ...)" 
-->
<xsl:function name="vm:getMethodSignature" as="xs:string">
	<xsl:param name="methodNode" as="node()"/>
	<xsl:value-of select="vm:getMethodSignature($methodNode, true())"/>
</xsl:function>

<!-- 
	returns the csharp or java signature (as determined by csharpMode) 
	of the given method node as "returnType methodName (type n1, type n2, ...)" 
-->
<xsl:function name="vm:getMethodSignature" as="xs:string">
	<xsl:param name="methodNode" as="node()"/>
	<xsl:param name="csharpMode" as="xs:boolean"/>
		
	<xsl:variable name="returnType" 
		select="if ($csharpMode)
				then vm:getType($methodNode/vm:signature/vm:return/@type)
				else $methodNode/vm:signature/vm:return/@type"/>
	<xsl:variable name="methodName" 
		select="if ($csharpMode) 
				then vm:getMemberNodeName($methodNode) 
				else $methodNode/@name"/>
	<xsl:variable name="params" as="xs:string*">
		<xsl:sequence select="'('"/>
		<xsl:for-each select="$methodNode/vm:signature/vm:parameter">
    		  <xsl:sequence select="if ($csharpMode)
    					  then vm:getType(@type)
    					  else @type"/>
    		  <xsl:if test="$csharpMode">
    		    <xsl:sequence select="' n'"/>
    		    <xsl:sequence select="xs:string(position())"/>
    		  </xsl:if>
    		  <xsl:if test="not(position()=last())">
    		    <xsl:sequence select="', '"/>
    		  </xsl:if>
		</xsl:for-each>
 		<xsl:sequence select="')'"/>
	</xsl:variable>
	<xsl:value-of select="fn:concat($returnType,' ', $methodName, 
    			                fn:string-join($params,''))" />
</xsl:function>

<!-- TODO: remove -->
<xsl:template name="appendSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(vm:signature/vm:parameter) != 0">
      <xsl:for-each select="vm:signature/vm:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@type)"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitWrapperComments">
	<xsl:param name="member"/>
	<xsl:param name="package"/>
	<xsl:param name="class"/>
	<xsl:variable name="tag" as="xs:string*">
		<xsl:sequence select="$package"/>
		<xsl:if test="$package and not($package='')">
			<xsl:sequence select="'.'"/>	
		</xsl:if>
		<xsl:sequence select="$class"/>
		<xsl:if test="$member and not($member='')">
			<xsl:sequence select="': '"/>
			<xsl:sequence select="$member"/>	
		</xsl:if>
	</xsl:variable>
	<xsl:variable name="tagStr" select="fn:string-join($tag,'')"/>
	<xsl:text>//XMLVM_BEGIN_WRAPPER[</xsl:text>
	<xsl:value-of select="$tagStr"/>
	<xsl:text>]&nl;</xsl:text>
	<xsl:text>//XMLVM_END_WRAPPER[</xsl:text>
	<xsl:value-of select="$tagStr"/>	
	<xsl:text>]&nl;</xsl:text>
</xsl:template>

    
<!--
   initLocals
   ==========
   This function is called from the template for <code>. Its task is
   to initialize the local variables. This basically means that the
   actual parameters have to be copied to _locals[i]. If the method
   is not static, 'this' will be copied to _locals[0].
-->
<!-- TODO: remove -->
<xsl:template name="initLocals">
    <xsl:for-each select="jvm:var">
		<xsl:choose>    
      		<xsl:when test="@name = 'this'">
      			<xsl:text>    _locals[</xsl:text>
    			<xsl:value-of select="@id" />
    			<xsl:text>].o = self;&nl;</xsl:text>
     		</xsl:when>
     		<xsl:otherwise>
     			<xsl:if test="(position()-count(../jvm:var[@name='this'])) &lt;= count(../../vm:signature/vm:parameter)" >
     			  <xsl:text>    _locals[</xsl:text>
     	  		  <xsl:value-of select="@id" />
     	  		  <xsl:text>]</xsl:text>
     	  		  <xsl:call-template name="emitTypedAccess">
     	  		    <xsl:with-param name="type" select="@type"/>
     	  		  </xsl:call-template>
     	  		  <xsl:text> = n</xsl:text>
     	  		  <xsl:value-of select="(position()-count(../jvm:var[@name='this']))" />
     	  		  <xsl:text>;&nl;</xsl:text>
     			</xsl:if>
     		</xsl:otherwise>
     	</xsl:choose>
    </xsl:for-each>
</xsl:template>


<xsl:template name="emitTypedAccess">
  <xsl:param name="type"/> 
  <xsl:text>.</xsl:text>
  <xsl:choose>
    <xsl:when test="$type = 'boolean' or $type = 'byte' or $type = 'char' or $type = 'short' or $type = 'int'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:text>f</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:text>d</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:text>l</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>o</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitTypedArrayAccess">
  <xsl:param name="type"/>
  
  <xsl:text>.</xsl:text>
  <xsl:choose>
    <xsl:when test="$type = 'boolean[]' or $type = 'byte[]'">
      <xsl:text>b</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'char[]'">
      <xsl:text>c</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'short[]'">
      <xsl:text>s</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'int[]'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float[]'">
      <xsl:text>f</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double[]'">
      <xsl:text>d</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long[]'">
      <xsl:text>l</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>o</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!--  javac will sometimes generate two methods that only differ in their return type.
      This can happen e.g. with type erasures. Function vm:isDuplicateMethod will determine
      if the given method is a duplicate that is not needed when generating Objective-C (in fact,
      Objective-C does not permit two methods that only differ in their return type).
      A method is a duplicate if it is (1) synthetic, (2) a method with the same name exists
      in the class, and (3) signatures only differ in their return types.  -->
<xsl:function name="vm:isDuplicateMethod" as="xs:boolean">
  <xsl:param name="method" as="node()"/>
  <xsl:choose>
    <xsl:when test="not($method/@isSynthetic = 'true')">
      <xsl:value-of select="false()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="name" select="$method/@name"/>
      <xsl:variable name="methodsWithSameName" select="$method/../vm:method[@name = $name]"/>
      <xsl:variable name="duplicateMethods">
        <xsl:for-each select="$methodsWithSameName">
          <xsl:if test="deep-equal($method/vm:signature/vm:parameter, ./vm:signature/vm:parameter)">
            <xsl:copy-of select="."/>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:value-of select="count($duplicateMethods/vm:method) gt 1"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:isObjectRef" as="xs:boolean">
  <xsl:param name="type" as="xs:string"/>
  <xsl:value-of select="not($type='byte' or $type='short' 
			    or $type='int' or $type='float' 
			    or $type='long' or $type='double' or
                            $type='char' or $type='boolean' or $type='void')"/>
</xsl:function>


<xsl:function name="vm:typeID" as="xs:integer">
  <xsl:param name="type" as="xs:string"/>
  
  <xsl:choose>
    <xsl:when test="$type='boolean'">
      <xsl:value-of select="1"/>
    </xsl:when>
    <xsl:when test="$type='char'">
      <xsl:value-of select="2"/>
    </xsl:when>
    <xsl:when test="$type='byte'">
      <xsl:value-of select="3"/>
    </xsl:when>
    <xsl:when test="$type='short'">
      <xsl:value-of select="4"/>
    </xsl:when>
    <xsl:when test="$type='int'">
      <xsl:value-of select="5"/>
    </xsl:when>
    <xsl:when test="$type='float'">
      <xsl:value-of select="6"/>
    </xsl:when>
    <xsl:when test="$type='double'">
      <xsl:value-of select="7"/>
    </xsl:when>
    <xsl:when test="$type='long'">
      <xsl:value-of select="8"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="0"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>



<xsl:function name="vm:fixname">
  <xsl:param  name="a"/>
  <xsl:value-of  select="replace(replace(replace($a,'\$', '_'),'\.','_'), '\[\]', '_ARRAYTYPE')"/>
</xsl:function>

<xsl:template name="emitRegisterDecl">
  <xsl:param name="num"/>
  <!-- value register -->
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$nonobj_regtype"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="$regname"/>
  <xsl:value-of select="$num"/>
  <xsl:value-of select="$nonobj_regname_suffix"/>    
  <xsl:text>;&nl;</xsl:text>
  <!-- object register -->
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$obj_regtype"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="$regname"/>
  <xsl:value-of select="$num"/>
  <xsl:value-of select="$obj_regname_suffix"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template name="emitRegisterName">
  <xsl:param name="num" />
  <xsl:param name="type" />
  <xsl:value-of select="$regname"/>
  <xsl:value-of select="$num"/>
  <xsl:value-of select="vm:getTypeAccess($type)"/>
</xsl:template>

<xsl:function name="vm:getTypeAccess" as="xs:string">
  <xsl:param name="type" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="$type = 'boolean' or $type = 'byte' 
		    or $type = 'char' or $type = 'short' or $type = 'int'">
      <xsl:value-of select="fn:concat($nonobj_regname_suffix, '.i')"/>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:value-of select="fn:concat($nonobj_regname_suffix, '.f')"/>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:value-of select="fn:concat($nonobj_regname_suffix, '.d')"/>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:value-of select="fn:concat($nonobj_regname_suffix, '.l')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$obj_regname_suffix"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

<!-- adopted from xmlvm2c.xsl -->
<xsl:template name="initArguments">
  <xsl:variable name="numRegs" select="dex:code/@register-size" as="xs:integer"/>
  <xsl:variable name="numArgs" select="count(vm:signature/vm:parameter)" as="xs:integer"/>
  <xsl:for-each select="1 to $numRegs">
  	<xsl:call-template name="emitRegisterDecl">
  		<xsl:with-param name="num" select="position()-1"/>
  	</xsl:call-template>
  </xsl:for-each>
  <xsl:if test="not(@isStatic = 'true')">
    <!-- Initialize 'this' parameter -->
    <xsl:text>    </xsl:text>
    <xsl:call-template name="emitRegisterName">
    	<xsl:with-param name="num" select="$numRegs - ($numArgs + 1)"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
    <xsl:text> = this;&nl;</xsl:text>
  </xsl:if>
  <xsl:for-each select="vm:signature/vm:parameter">
    <xsl:text>    </xsl:text>
    <xsl:call-template name="emitRegisterName">
    	<xsl:with-param name="num" select="$numRegs - ($numArgs - position()) - 1"/>
    	<xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text> = n</xsl:text>
    <xsl:value-of select="position()"/>
    <xsl:text>;&nl;</xsl:text>
  </xsl:for-each>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="$xmlvmExceptionType"/>
  <xsl:text> _ex = null;&nl;</xsl:text>
</xsl:template>


  
<xsl:template match="vm:annotations">
  <!-- Ignore annotations -->
</xsl:template>


<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- **********************************************************************************-->
<!-- DEX Templates -->
<!-- http://www.netmite.com/android/mydroid/dalvik/docs/dalvik-bytecode.html-->
<!-- http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html -->


<xsl:template match="dex:code">
	<xsl:apply-templates/>
</xsl:template>


<xsl:template match="vm:set-null">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
  	<xsl:with-param name="type" select="'obj'"/>
  	<xsl:with-param name="num" select="@num"/>
  </xsl:call-template>
  <xsl:text> = null;&nl;</xsl:text>
</xsl:template>

<xsl:template match="vm:move-argument">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
  	<xsl:with-param name="type" select="@vx-type"/>
  	<xsl:with-param name="num" select="@vx"/>
  </xsl:call-template>
 <xsl:if test="@sourceArg = 'self'">
   <xsl:text> = self;&nl;</xsl:text>
 </xsl:if>
 <xsl:if test="@sourceArg != 'self'">
   <xsl:text> = n</xsl:text><xsl:value-of select="@sourceArg"/>
 <xsl:text>;
</xsl:text>
 </xsl:if>
</xsl:template>

<!--
<xsl:template match="vm:define-register">
  <xsl:choose>
 	<xsl:when test = "@vartype = 'register'">
 	  <xsl:text>    </xsl:text>
	  <xsl:call-template name="emitRegisterDecl">
  		<xsl:with-param name="num" select="@num"/>
	  </xsl:call-template>
 	</xsl:when>
 	<xsl:when test = "@vartype = 'temp'">
 	  <xsl:text>    </xsl:text>
	  <xsl:call-template name="emitRegisterDecl">
  		<xsl:with-param name="num" select="'tmp'"/>
	  </xsl:call-template>
 	</xsl:when>
 	<xsl:when test = "@vartype = 'exception'">
        <xsl:text>    id        _ex = null;&nl;</xsl:text>
 	</xsl:when>
  </xsl:choose>
</xsl:template>
-->

<xsl:template match="dex:var">
  <!-- Do nothing -->
</xsl:template>

<xsl:template match="vm:source-position">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:invoke-static|dex:invoke-static-range">
  <xsl:text>    </xsl:text>
  <xsl:if test="(dex:parameters/dex:return/@type != 'void') and dex:move-result">
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="dex:move-result/@vx" />
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:value-of select="vm:getType(@class-type)"/>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:getPublicMemberName(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="vm:getType(@type)"/>
    <xsl:text>) </xsl:text>
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:invoke-direct|dex:invoke-direct-range
		     |dex:invoke-virtual|dex:invoke-virtual-range
		     |dex:invoke-interface|dex:invoke-interface-range">
  <xsl:text>    </xsl:text>
  <xsl:if test="(dex:parameters/dex:return/@type != 'void') and dex:move-result">
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="dex:move-result/@vx"/>
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>((</xsl:text>
  <xsl:variable name="baseClass">
    <xsl:value-of select="ancestor::dex:class/@extends"/>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="name() = 'dex:invoke-virtual' 
		    or compare(@class-type,$baseClass) != 0">
      <xsl:value-of select="vm:getType(@class-type)"/>
      <xsl:text>) </xsl:text>
      <xsl:call-template name="emitRegisterName">
	<xsl:with-param name="num" select="@register"/>
  	<xsl:with-param name="type" select="'obj'"/>
      </xsl:call-template>
      <xsl:text>)</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>super))</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:getPublicMemberName(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="vm:getType(@type)"/>
    <xsl:text>) </xsl:text>
    <xsl:call-template name="emitRegisterName">
    		<xsl:with-param name="num" select="@register"/>
    		<xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:invoke-super|dex:invoke-super-range">
  <xsl:text>    </xsl:text>
  <xsl:if test="(dex:parameters/dex:return/@type != 'void') and dex:move-result">
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="dex:move-result/@vx"/>
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>base</xsl:text>
  <xsl:text>.</xsl:text>
  <xsl:value-of select="vm:getPublicMemberName(@method)"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>(</xsl:text>
    <xsl:value-of select="vm:getType(@type)"/>
    <xsl:text>) </xsl:text>
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:if test="not(position()=last())">
      <xsl:text>, </xsl:text>    
    </xsl:if>
  </xsl:for-each>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:monitor-enter">
  <!-- We can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter in order
       to handle exceptions. Also, wait() and wait(long) need to be
       able to release the Object's monitor (the synchronized lock)-->
	<xsl:text>    Monitor.Enter(</xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:monitor-exit">
  <!-- We can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter in order
       to handle exceptions. Also, wait() and wait(long) need to be
       able to release the Object's monitor (the synchronized lock)-->
	<xsl:text>    Monitor.Exit(</xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
    	<xsl:with-param name="type" select="'obj'"/>
    </xsl:call-template>
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:try-catch">
    <xsl:apply-templates/>
    <xsl:for-each select="dex:catch">
        <xsl:if test="position()=1">
            <xsl:text>    catch (</xsl:text>
	    <xsl:value-of select="$xmlvmExceptionType"/>
	    <xsl:text> ex) {&nl;</xsl:text>
            <xsl:text>        global::System.Object _java_exception</xsl:text>
	    <xsl:text> = ex.getJavaException();&nl;</xsl:text>
	</xsl:if>
	<xsl:text>        if (_java_exception is </xsl:text>
	<xsl:value-of select="vm:getType(@exception-type)"/>
	<xsl:text>) {&nl;            _ex = ex;&nl;</xsl:text>
	<xsl:text>            goto label</xsl:text>
	<xsl:value-of select="@target"/>
	<xsl:text>;&nl;        }&nl;</xsl:text>
	<xsl:if test="position()=last()">
	    <xsl:text>        throw ex;&nl;</xsl:text>
            <xsl:text>    } // end catch&nl;</xsl:text>
	</xsl:if>
    </xsl:for-each>
</xsl:template>


<xsl:template match="dex:try">
  <xsl:text>    try {&nl;</xsl:text>
  <xsl:apply-templates/>
  <xsl:text>}&nl;</xsl:text>
</xsl:template>

<xsl:function name="vm:getExceptionRegister" as="xs:integer">
  <xsl:param name="root" as="node()"/>
  <xsl:param name="target" as="xs:integer"/>
  <xsl:value-of select="$root/descendant::dex:label[@id = $target]/following-sibling::dex:move-exception[position()=1]/@vx"/>
</xsl:function>

<xsl:template match="dex:catch">
</xsl:template>



<xsl:template match="dex:catches">
  <!-- do nothing -->
</xsl:template>


<xsl:template match="dex:throw">
	<xsl:text>    throw new </xsl:text>
	<xsl:value-of select="$xmlvmExceptionType"/>
	<xsl:text>((</xsl:text>
	<xsl:value-of select="vm:getType(@vx-type)"/>
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:move-exception">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text> = _ex.getJavaException();&nl;    _ex = null;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int|dex:add-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:sub-int|dex:sub-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:mul-int|dex:mul-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-int|dex:div-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:rem-int|dex:rem-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> % </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:add-float|dex:add-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-float|dex:sub-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-float|dex:mul-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-float|dex:div-float-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'float'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-double|dex:add-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-double|dex:sub-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-double|dex:mul-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-double|dex:div-double-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'double'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:add-long|dex:add-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> + </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-long|dex:sub-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> - </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-long|dex:mul-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> * </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-long|dex:div-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> / </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-long|dex:rem-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> % </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:and-int|dex:and-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &amp; </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:and-long|dex:and-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> &amp; </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int|dex:shl-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &lt;&lt; </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-long|dex:shl-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> &lt;&lt; (0x3f &amp; </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:and-int-lit8|dex:and-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &amp; </xsl:text>
	<xsl:value-of select="@value"/>	
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int-lit8|dex:shl-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &lt;&lt; </xsl:text>
	<xsl:value-of select="@value"/>	
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-int-lit8|dex:shr-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &gt;&gt; </xsl:text>
	<xsl:value-of select="@value"/>	
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-int-lit8|dex:ushr-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> &gt;&gt; (0x1f &amp; </xsl:text>
	<xsl:value-of select="@value"/>	
	<xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-long|dex:ushr-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = ((unsigned long) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>) &gt;&gt; (0x3f &amp; ((unsigned long) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>));&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:or-int-lit8|dex:or-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> | </xsl:text>
	<xsl:value-of select="@value"/>	
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int-lit8|dex:xor-int-lit16">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> ^ </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int|dex:xor-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> ^ </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-int|dex:or-int-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text> | </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'int'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-long|dex:or-long-2addr">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text> | </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vz"/>
		<xsl:with-param name="type" select="'long'"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:return-void">
  <xsl:text>    return;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:return|dex:return-wide|dex:return-object">
	<!-- TODO: fix this to catch exceptions a la csharp -->
	<xsl:if test="@catchesException = 'true'">
    	<xsl:text>    [_ex release];&nl;</xsl:text>
	</xsl:if>
	<xsl:variable name="return-type" select="ancestor::vm:method/vm:signature/vm:return/@type" />
	<xsl:text>    return (</xsl:text>
	<xsl:value-of select="vm:getType($return-type)"/>
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx" />  
		<xsl:with-param name="type" select="$return-type" />  		
	</xsl:call-template>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:new-instance">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text> = new </xsl:text>
	<xsl:value-of select="vm:getType(@value)" />
	<xsl:text>();&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:iget|dex:iget-wide|dex:iget-boolean|dex:iget-byte">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="@member-type"/>  	
	</xsl:call-template>
	<xsl:text> = (</xsl:text>
	<xsl:value-of select="vm:getType(@member-type)" />	
	<xsl:text>) ((</xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
    <xsl:text>).</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:iget-object">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="@member-type"/>  	
	</xsl:call-template>
	<xsl:text> = (</xsl:text>
	<xsl:value-of select="vm:getType(@member-type)" />	
	<xsl:text>) ((</xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
    <xsl:text>).</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:iput|dex:iput-wide|dex:iput-boolean|dex:iput-byte">
	<xsl:text>    ((</xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text>).</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text> = (</xsl:text>
	<xsl:value-of select="vm:getType(@member-type)" />	
	<xsl:text>) </xsl:text>	
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="@member-type"/>  	
	</xsl:call-template>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

<!--
<xsl:template match="vm:tmp-equals-r">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="'tmp'"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text> = </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@reg"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>
-->

<xsl:template match="vm:comment">
	<xsl:text>    //INFO: </xsl:text>
	<xsl:value-of select="@text" />
	<xsl:text>&nl;  </xsl:text>
</xsl:template>

<xsl:template match="vm:reg-release">
</xsl:template>

<xsl:template match="vm:reg-retain">
</xsl:template>
  
<xsl:template match="vm:i-release">
</xsl:template>

<xsl:template match="dex:iput-object">
	<xsl:text>    ((</xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vy"/>
  		<xsl:with-param name="type" select="'obj'"/>  	
	</xsl:call-template>
	<xsl:text>).</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text> = (</xsl:text>
	<xsl:value-of select="vm:getType(@member-type)" />	
	<xsl:text>)	</xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
  		<xsl:with-param name="type" select="@member-type"/>  	
	</xsl:call-template>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:sget|dex:sget-wide|dex:sget-boolean|dex:sget-object">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="@member-type"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>.</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="vm:s-release">
</xsl:template>

<xsl:template match="dex:sput|dex:sput-wide|dex:sput-boolean|dex:sput-object">
	<xsl:text>    </xsl:text>
	<xsl:value-of select="vm:getType(@class-type)" />
	<xsl:text>.</xsl:text>
	<xsl:value-of select="vm:getPublicMemberName(@member-name)"/>
	<xsl:text> = (</xsl:text>
	<xsl:value-of select="vm:getType(@member-type)" />	
	<xsl:text>) </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="@member-type"/>
	</xsl:call-template> 
	<xsl:text>;&nl;</xsl:text>
</xsl:template>



<xsl:template match="dex:const-4[@kind='known-null']|dex:const-8[@kind='known-null']|dex:const-16[@kind='known-null']"> 
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
    <xsl:text> = null;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:const|dex:const-4|dex:const-16|dex:const-wide|dex:const-wide-16|dex:const-wide-32|dex:const-high16|dex:const-wide-high16"> 
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="@type"/>
	</xsl:call-template> 
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:choose>
	  <xsl:when test="@type='float'">
	    <xsl:text>f</xsl:text>
	  </xsl:when>
	  <xsl:when test="@type='double'">
	    <xsl:text>d</xsl:text>
	  </xsl:when>
	  <xsl:when test="@type='long'">
	    <xsl:text>l</xsl:text>
	  </xsl:when>
	</xsl:choose>
	<xs:text>;&nl;</xs:text>
</xsl:template>

<!-- following helper function is inspired by xmlvm2c.xsl -->
<xsl:function name="vm:escapeString">
  <xsl:param  name="string"/>
  <!-- Escape all \\ \t(011) \n(012) \r(015) \f(014) \b(010) \" -->
  <!-- Single quotes don't need to be escaped. -->
  <!-- 
       notes to self:
       step1: we double all the backslashes
       step2: we replace \010 with b
       situation 1: java str: "\\"
                    xmlvm str: "\"
                    after step1: "\\"
                    after step2: "\\" (no change)
       situation 2: java str: "\b"
                    xmlvm str: "\010"
                    after step1: "\\010"
                    after step2: "\b"
       ambiguous situation: java str: "\\012", "\n"
                            xmlvm str: "\012" = "\012"
                            cannot resolve...
       note 1: we cannot double the backslashes as second step
               (otherwise may get "\010" to "\b" to "\\b"...)
       note 2: we have to deal with "\134" after we deal with "\"
               and with "\\042" after we deal with "&quot"
               (otherwise may get "\\042" to "\\&quot" to "\\\\&quot"...)
       TODO: unicode chars
  -->
  <xsl:text>"</xsl:text>                                                
  <xsl:value-of select="replace(replace(replace(replace(replace(replace(replace(
			replace(replace($string,'\\','\\\\'),'\\134','\\'),
                        '\\011','t'),'\\012','n'),'\\015','r'),'\\014','f'),'\\010','b'),
                        '&quot;','\\&quot;'),'\\042','&quot;')"/>                               
  <xsl:text>"</xsl:text>
</xsl:function>


<xsl:template match="dex:const-string">
	<xsl:text>    </xsl:text>
	<xsl:call-template name="emitRegisterName">
		<xsl:with-param name="num" select="@vx"/>
		<xsl:with-param name="type" select="'obj'"/>
	</xsl:call-template> 
	<xsl:text> = new </xsl:text>
	<xsl:value-of select="vm:getType('java.lang.String')"/>
	<xsl:text>(</xsl:text>
	<xsl:value-of select="vm:escapeString(@value)"/>
	<xsl:text>);&nl;</xsl:text>
<!--	<xsl:text>("</xsl:text>  -->
  <!-- Escape all \\ \t(011) \n(012) \r(015) \f(014) \b(010) \" -->
  <!-- Single quotes don't need to be escaped. -->
  <!-- PROBLEM! Because backslashes aren't already escaped in @value, there
       is no way to differ both Java Strings of "\\011" and "\t". So they'll
       both be translated to "\t". That is also true for the other escaped characters.-->
<!--	<xsl:value-of select="replace(replace(replace(replace(replace(replace(replace(@value,'\\','\\\\'),
  	                       '\\\\011','\\t'),'\\\\012','\\n'),'\\\\015','\\r'),'\\\\014','\\f'),'\\\\010','\\b'),
  	                       '&quot;','\\&quot;')"/>
  <xs:text>");&nl;</xs:text>  -->

</xsl:template>


<xsl:template match="dex:const-class"> 
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:getType(@value)"/>
  <xs:text>.getClass();&nl;</xs:text>
</xsl:template>


<xsl:template match="dex:float-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (double) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-byte">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; 24) &gt;&gt; 24;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-short">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; 16) &gt;&gt; 16;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (float) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (long) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (double) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-char">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &amp; 0xffff;
</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (float) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (float) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (long) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmp-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int-lit8|dex:add-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> + </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-int-lit8|dex:mul-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> * </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:div-int-lit8|dex:div-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> / </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-int-lit8|dex:rem-int-lit16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> % </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:goto|dex:goto-16">
  <xsl:text>    goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eqz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>null</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-nez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != </xsl:text>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>null</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ltz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lez">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gtz">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ge">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gt">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-le">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lt">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eq">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ne">
  <xsl:text>    if (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:sparse-switch|dex:packed-switch">
  <xsl:text>    switch (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i) {
</xsl:text>
  <xsl:for-each select="dex:case">
    <xsl:text>    case </xsl:text>
    <xsl:value-of select="@key"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;
</xsl:text>
  </xsl:for-each>
  <xsl:text>    }
</xsl:text>
</xsl:template>

<!-- ******************* Begin Arrays ******************************** -->

<xsl:function name="vm:getArrayBaseType" as="xs:string">
  <xsl:param name="arrayType" as="xs:string" />
  <xsl:value-of select="fn:substring($arrayType, 1, 
			             fn:string-length($arrayType) - 2)"/>
</xsl:function>

<xsl:function name="vm:getXmlvmArray" as="xs:string">
  <xsl:param name="baseType"/>
  <xsl:value-of select="fn:concat($xmlvmArrayType,
			          '&lt;',
				  if (vm:isObjectRef($baseType))
				    then $obj_regtype
				    else $baseType,
				  '&gt;')"/>
</xsl:function>

<xsl:template name="emitNewArray">
  <xsl:param name="arrayInitializer" as="xs:string"/>
  <xsl:param name="baseType" as="xs:string"/>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = new </xsl:text>
  <xsl:value-of select="vm:getXmlvmArray($baseType)"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="fn:concat('new ', 
			          if (vm:isObjectRef($baseType))
				    then $obj_regtype
				    else $baseType,
				  $arrayInitializer)"/>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:new-array">
  <xsl:variable name="baseType" select="vm:getArrayBaseType(@value)"/>
  <xsl:variable name="arrayInitializer">
    <xsl:text>[</xsl:text>
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="@vy"/>
      <xsl:with-param name="type" select="'int'"/>
    </xsl:call-template>
    <xsl:text>]</xsl:text>
  </xsl:variable>
  <xsl:call-template name="emitNewArray">
    <xsl:with-param name="arrayInitializer" select="$arrayInitializer"/>
    <xsl:with-param name="baseType" select="$baseType"/>
  </xsl:call-template>
</xsl:template>


<xsl:template match="dex:aget|dex:aget-wide|dex:aget-boolean|dex:aget-byte|dex:aget-char|dex:aget-short">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:value-of select="vm:getXmlvmArray(vm:getArrayBaseType(@vy-type))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>get</xsl:text>
  <xsl:text>(</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:aget-object">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:value-of select="vm:getXmlvmArray(vm:getArrayBaseType('obj'))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>get</xsl:text>
  <xsl:text>(</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>);&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:aput|dex:aput-wide|dex:aput-boolean|dex:aput-char|dex:aput-byte|dex:aput-short">
  <xsl:text>    ((</xsl:text>
  <xsl:value-of select="vm:getXmlvmArray(vm:getArrayBaseType(@vy-type))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>set</xsl:text>
  <xsl:text>(</xsl:text>
  <!-- new value -->
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text>, </xsl:text>
  <!-- index -->
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

  
<xsl:template match="dex:aput-object">
  <xsl:text>    ((</xsl:text>
  <xsl:value-of select="vm:getXmlvmArray(vm:getArrayBaseType('obj'))"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).</xsl:text>
  <xsl:text>set</xsl:text>
  <xsl:text>(</xsl:text>
  <!-- new value -->
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>, </xsl:text>
  <!-- index -->
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vz"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text>)</xsl:text>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:array-length">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:value-of select="$xmlvmArrayInterface"/>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>).getLength();&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:fill-array-data">
  <xsl:variable name="baseType" select="vm:getArrayBaseType(@vx-type)"/>
  <xsl:variable name="valSuffix">
    <xsl:choose>
      <xsl:when test="$baseType='float'">
	<xsl:text>f</xsl:text>
      </xsl:when>
      <xsl:when test="$baseType='double'">
	<xsl:text>d</xsl:text>
      </xsl:when>
      <xsl:when test="$baseType='long'">
	<xsl:text>l</xsl:text>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="arrayInitializer">
    <xsl:text>[]{</xsl:text>
    <xsl:for-each select="dex:constant">
      <xsl:value-of select="fn:concat(@value, $valSuffix)"/>
      <xsl:if test="not(position()=last())">
	<xsl:text>, </xsl:text>
      </xsl:if>
    </xsl:for-each>
    <xsl:text>}</xsl:text>
  </xsl:variable>
  <xsl:call-template name="emitNewArray">
    <xsl:with-param name="arrayInitializer" select="$arrayInitializer"/>
    <xsl:with-param name="baseType" select="$baseType"/>
  </xsl:call-template>
</xsl:template>


<!--
<xsl:template match="dex:filled-new-array|dex:filled-new-array-range">
  <xsl:variable name="baseType" select="vm:getArrayBaseType(@value)"/>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = (id) ((XMLVMElem[]) {</xsl:text>
  <xsl:for-each select="dex:value">
    <xsl:call-template name="emitRegisterName">
      <xsl:with-param name="num" select="@register"/>
      <xsl:with-param name="type" select="$baseType"/>
    </xsl:call-template>
    <xsl:text>, </xsl:text>
  </xsl:for-each>
  <xsl:text>});&nl;</xsl:text>
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = [XMLVMArray createSingleDimensionWithType:</xsl:text>
  <xsl:value-of select="vm:typeID($baseType)"/>
  <xsl:text> size:</xsl:text>
  <xsl:value-of select="count(dex:value)"/>
  <xsl:text> andData:_r</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="dex:move-result/@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>];&nl;</xsl:text>
</xsl:template>
-->


<!--
<xsl:template match="vm:a-release">
    <xsl:text>    [((XMLVMArray*) _r</xsl:text>
    <xsl:value-of select="@vy" />
    <xsl:text>.o)->array.o[_r</xsl:text>
    <xsl:value-of select="@vz" />
    <xsl:text>.i] release];&nl;</xsl:text>
</xsl:template>
-->

<!-- ******************* End Arrays ******************************** -->


<xsl:template match="dex:check-cast">
  <!-- TODO should do a runtime type check -->
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>


<xsl:template match="dex:instance-of">
  <!-- 
     @value = actual type
     @vy-type = apparent type
     @vy = object reference
     @vx = result (boolean)
  -->
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'int'"/>
  </xsl:call-template>
  <xsl:text> = ((</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text> != null) &amp;&amp; (</xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text> is </xsl:text>
  <xsl:value-of select="vm:getType(@value)"/>
  <xsl:text>)) ? 1 : 0;&nl;</xsl:text>
</xsl:template>



<xsl:template match="dex:move|dex:move-from16|dex:move-wide|dex:move-wide-from16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>

<xsl:template match="dex:move-object|dex:move-object-from16">
  <xsl:text>    </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vx"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:call-template name="emitRegisterName">
    <xsl:with-param name="num" select="@vy"/>
    <xsl:with-param name="type" select="'obj'"/>
  </xsl:call-template>
  <xsl:text>;&nl;</xsl:text>
</xsl:template>





<xsl:template name="appendDexSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(dex:parameters/dex:parameter) != 0">
      <xsl:for-each select="dex:parameters/dex:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="replace(vm:fixname(@type), '\[\]', '_ARRAYTYPE')"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>



<!--
   Default template. If the XMLVM file should contain an instruction
   that is not handled by this stylesheet, this default template
   will make sure we notice it by writing a special error function
   to the output stream.
-->
<xsl:template match="*">
  <xsl:text>      ERROR("</xsl:text>
  <xsl:value-of select="name()"/>
    <xsl:text>");
</xsl:text>
  <xsl:message select="."/>
</xsl:template>


</xsl:stylesheet>
